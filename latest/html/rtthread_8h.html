<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Doxygen Awesome" />
<meta property="og:image" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta property="og:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<meta property="og:url" content="https://jothepro.github.io/doxygen-awesome-css/" />
<!-- END opengraph metadata -->
<!-- BEGIN twitter metadata -->
<meta name="twitter:image:src" content="https://repository-images.githubusercontent.com/348492097/4f16df80-88fb-11eb-9d31-4015ff22c452" />
<meta name="twitter:title" content="Doxygen Awesome" />
<meta name="twitter:description" content="Custom CSS theme for doxygen html-documentation with lots of customization parameters." />
<!-- END twitter metadata -->
<title>RT-Thread RTOS: include/rtthread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" type="image/svg+xml" href="logo.drawio.svg"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
<script type="text/javascript" src="toggle-alternative-theme.js"></script>
<script type="text/javascript" src="version-switcher.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
    DoxygenAwesomeInteractiveToc.init()
    DoxygenAwesomeTabs.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://github.com/kurisaW/docs" class="github-corner" title="View source on GitHub" target="_blank" rel="noopener noreferrer">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RT-Thread RTOS
   &#160;<span id="projectnumber">main</span>
   </div>
   <div id="projectbrief">An real-time operating system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rtthread_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rtthread.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;rtconfig.h&gt;</code><br />
<code>#include &lt;<a class="el" href="rtdef_8h_source.html">rtdef.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rtservice_8h_source.html">rtservice.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rtm_8h_source.html">rtm.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rtatomic_8h_source.html">rtatomic.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="rtklibc_8h_source.html">rtklibc.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="finsh_8h_source.html">finsh.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for rtthread.h:</div>
<div class="dyncontent">
<div class="center"><img src="rtthread_8h__incl.png" border="0" usemap="#ainclude_2rtthread_8h" alt=""/></div>
<map name="ainclude_2rtthread_8h" id="ainclude_2rtthread_8h">
<area shape="rect" title=" " alt="" coords="229,5,366,31"/>
<area shape="rect" title=" " alt="" coords="53,445,136,471"/>
<area shape="poly" title=" " alt="" coords="229,26,158,38,121,49,86,62,55,80,30,103,14,130,8,164,8,312,14,349,31,382,52,411,73,434,69,438,48,414,26,385,9,350,3,313,3,163,9,128,26,99,52,76,83,58,119,43,157,33,228,21"/>
<area shape="rect" href="rtdef_8h.html" title=" " alt="" coords="416,225,480,251"/>
<area shape="poly" title=" " alt="" coords="367,18,401,24,436,34,469,52,495,77,504,94,508,113,502,150,487,186,468,215,463,213,482,184,497,149,503,113,499,96,491,80,466,56,434,39,400,29,366,23"/>
<area shape="rect" href="rtservice_8h.html" title=" " alt="" coords="556,152,647,177"/>
<area shape="poly" title=" " alt="" coords="367,21,452,38,497,54,539,77,570,106,591,138,587,141,566,109,536,81,495,59,451,44,366,27"/>
<area shape="rect" href="rtm_8h.html" title=" " alt="" coords="221,79,278,104"/>
<area shape="poly" title=" " alt="" coords="285,33,259,68,254,65,280,29"/>
<area shape="rect" href="rtatomic_8h.html" title=" " alt="" coords="302,79,391,104"/>
<area shape="poly" title=" " alt="" coords="308,29,333,66,329,69,303,33"/>
<area shape="rect" href="rtklibc_8h.html" title=" " alt="" coords="152,152,227,177"/>
<area shape="poly" title=" " alt="" coords="271,33,239,52,210,80,198,109,193,139,187,138,192,108,206,77,235,48,268,28"/>
<area shape="rect" href="finsh_8h.html" title=" " alt="" coords="415,79,481,104"/>
<area shape="poly" title=" " alt="" coords="323,28,412,70,410,75,320,33"/>
<area shape="rect" href="rtsched_8h.html" title=" " alt="" coords="407,299,489,324"/>
<area shape="poly" title=" " alt="" coords="451,251,451,285,445,285,445,251"/>
<area shape="rect" href="rttypes_8h.html" title=" " alt="" coords="425,372,505,397"/>
<area shape="poly" title=" " alt="" coords="465,249,487,270,504,298,507,315,503,333,487,363,482,360,498,331,501,315,499,300,482,273,462,253"/>
<area shape="rect" href="rtcompiler_8h.html" title=" " alt="" coords="302,372,402,397"/>
<area shape="poly" title=" " alt="" coords="438,253,397,300,364,361,360,358,392,297,434,249"/>
<area shape="rect" title=" " alt="" coords="221,299,331,324"/>
<area shape="poly" title=" " alt="" coords="421,253,318,296,316,291,419,248"/>
<area shape="poly" title=" " alt="" coords="453,324,462,358,457,360,448,325"/>
<area shape="poly" title=" " alt="" coords="434,326,380,366,377,361,431,322"/>
<area shape="poly" title=" " alt="" coords="426,398,414,400,150,450,149,444,413,395,425,392"/>
<area shape="rect" title=" " alt="" coords="761,445,831,471"/>
<area shape="poly" title=" " alt="" coords="506,392,748,443,747,448,505,397"/>
<area shape="rect" title=" " alt="" coords="200,445,275,471"/>
<area shape="poly" title=" " alt="" coords="429,400,288,444,287,439,428,395"/>
<area shape="rect" title=" " alt="" coords="299,445,373,471"/>
<area shape="poly" title=" " alt="" coords="446,400,371,441,368,436,443,395"/>
<area shape="rect" title=" " alt="" coords="397,445,493,471"/>
<area shape="poly" title=" " alt="" coords="465,398,455,433,450,431,459,397"/>
<area shape="rect" title=" " alt="" coords="518,445,613,471"/>
<area shape="poly" title=" " alt="" coords="483,395,539,435,536,439,480,400"/>
<area shape="rect" title=" " alt="" coords="637,445,736,471"/>
<area shape="poly" title=" " alt="" coords="502,395,639,439,637,444,500,400"/>
<area shape="poly" title=" " alt="" coords="311,400,150,444,149,439,310,395"/>
<area shape="poly" title=" " alt="" coords="578,180,486,222,484,217,576,175"/>
<area shape="poly" title=" " alt="" coords="262,77,288,41,292,44,266,80"/>
<area shape="poly" title=" " alt="" coords="259,103,285,138,323,175,363,200,404,219,402,224,361,205,320,179,281,141,255,106"/>
<area shape="rect" href="rthw_8h.html" title=" " alt="" coords="334,152,397,177"/>
<area shape="poly" title=" " alt="" coords="352,104,361,138,356,140,347,105"/>
<area shape="poly" title=" " alt="" coords="380,175,426,214,422,218,377,179"/>
<area shape="poly" title=" " alt="" coords="153,178,114,196,97,210,84,227,72,252,66,280,65,337,75,390,88,432,82,433,70,391,60,337,60,279,67,251,79,224,93,206,112,192,151,173"/>
<area shape="poly" title=" " alt="" coords="228,174,403,222,402,227,226,179"/>
<area shape="poly" title=" " alt="" coords="228,172,302,193,335,208,356,224,361,244,352,263,335,280,314,294,311,290,331,276,348,260,356,244,351,227,332,212,300,198,226,177"/>
<area shape="rect" title=" " alt="" coords="93,225,208,251"/>
<area shape="poly" title=" " alt="" coords="185,179,166,215,161,212,181,176"/>
<area shape="rect" title=" " alt="" coords="232,225,341,251"/>
<area shape="poly" title=" " alt="" coords="207,175,261,215,258,219,203,180"/>
<area shape="poly" title=" " alt="" coords="451,104,451,212,445,212,445,104"/>
</map>
</div>
</div>
<p><a href="rtthread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrt__mq__message.html">rt_mq_message</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga94d3b85f04028c8d67de67151c21c60d" id="r_ga94d3b85f04028c8d67de67151c21c60d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga94d3b85f04028c8d67de67151c21c60d">RT_SCHEDULER_STACK_CHECK</a>(thr)</td></tr>
<tr class="separator:ga94d3b85f04028c8d67de67151c21c60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa353d2d0c5addbb2ed60f06fd85e0442" id="r_gaa353d2d0c5addbb2ed60f06fd85e0442"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#gaa353d2d0c5addbb2ed60f06fd85e0442">RT_THREAD_RESUME_RES_THR_ERR</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:gaa353d2d0c5addbb2ed60f06fd85e0442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f53ffe3fad5a0d72915626909f3ebea" id="r_ga1f53ffe3fad5a0d72915626909f3ebea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga1f53ffe3fad5a0d72915626909f3ebea">RT_MQ_BUF_SIZE</a>(msg_size,  max_msgs)&#160;&#160;&#160;((<a class="el" href="group__group___basic_def.html#ga8e803706fb0e206869f5f706c1289949">RT_ALIGN</a>((msg_size), RT_ALIGN_SIZE) + sizeof(struct <a class="el" href="structrt__mq__message.html">rt_mq_message</a>)) * (max_msgs))</td></tr>
<tr class="separator:ga1f53ffe3fad5a0d72915626909f3ebea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5294e0b27a4f200d2dbeb7334fdec8b" id="r_ac5294e0b27a4f200d2dbeb7334fdec8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#ac5294e0b27a4f200d2dbeb7334fdec8b">rt_cpu_get_id</a>()&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ac5294e0b27a4f200d2dbeb7334fdec8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc5c9066908cd34d36848d8a281b472" id="r_ga2cc5c9066908cd34d36848d8a281b472"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga2cc5c9066908cd34d36848d8a281b472">rt_kprintf</a>(...)</td></tr>
<tr class="separator:ga2cc5c9066908cd34d36848d8a281b472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0224c23e19af562c32f17bd455929029" id="r_ga0224c23e19af562c32f17bd455929029"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga0224c23e19af562c32f17bd455929029">rt_kputs</a>(str)</td></tr>
<tr class="separator:ga0224c23e19af562c32f17bd455929029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a86c5965ba3874257e3cb99a3536b70" id="r_ga6a86c5965ba3874257e3cb99a3536b70"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga6a86c5965ba3874257e3cb99a3536b70">RT_ASSERT</a>(EX)&#160;&#160;&#160;{<a class="el" href="rtdef_8h.html#a6be8b4b10fed3667deba827ed6dcedfc">RT_UNUSED</a>(EX);}</td></tr>
<tr class="separator:ga6a86c5965ba3874257e3cb99a3536b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga698d553ac77f87923ab3cb235348e7c7" id="r_ga698d553ac77f87923ab3cb235348e7c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga698d553ac77f87923ab3cb235348e7c7">RT_DEBUG_NOT_IN_INTERRUPT</a></td></tr>
<tr class="separator:ga698d553ac77f87923ab3cb235348e7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae408b850f1e084635c3e766e3d9db2c9" id="r_gae408b850f1e084635c3e766e3d9db2c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#gae408b850f1e084635c3e766e3d9db2c9">RT_DEBUG_IN_THREAD_CONTEXT</a></td></tr>
<tr class="separator:gae408b850f1e084635c3e766e3d9db2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b653a32b710bfa448d3a5b2e38d7176" id="r_ga9b653a32b710bfa448d3a5b2e38d7176"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga9b653a32b710bfa448d3a5b2e38d7176">RT_DEBUG_SCHEDULER_AVAILABLE</a>(need_check)</td></tr>
<tr class="separator:ga9b653a32b710bfa448d3a5b2e38d7176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0e2e14ce8c372f4e5b69f661b963c16" id="r_gaf0e2e14ce8c372f4e5b69f661b963c16"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#gaf0e2e14ce8c372f4e5b69f661b963c16">rt_sched_thread_is_binding</a>(thread)&#160;&#160;&#160;(<a class="el" href="rttypes_8h.html#a5e3d4a1b993df67473bc161096dba218">RT_TRUE</a>)</td></tr>
<tr class="separator:gaf0e2e14ce8c372f4e5b69f661b963c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga7834be0d0c62aaa32ae47ade3ac21e68" id="r_ga7834be0d0c62aaa32ae47ade3ac21e68"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga7834be0d0c62aaa32ae47ade3ac21e68">rt_thread_inited_hookproto_t</a>) (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:ga7834be0d0c62aaa32ae47ade3ac21e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a hook function when a thread is initialized.  <br /></td></tr>
<tr class="separator:ga7834be0d0c62aaa32ae47ade3ac21e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8cb85e5812b8e7c3705fb3c7702c992b" id="r_ga8cb85e5812b8e7c3705fb3c7702c992b"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrt__object__information.html">rt_object_information</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga8cb85e5812b8e7c3705fb3c7702c992b">rt_object_get_information</a> (enum <a class="el" href="group__group___kernel_object.html#ga38a532bcb1bd3f12685db4219b761b56">rt_object_class_type</a> type)</td></tr>
<tr class="memdesc:ga8cb85e5812b8e7c3705fb3c7702c992b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the specified type of object information.  <br /></td></tr>
<tr class="separator:ga8cb85e5812b8e7c3705fb3c7702c992b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga999d82dfa646d3c4416698f35e37ed65" id="r_ga999d82dfa646d3c4416698f35e37ed65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga999d82dfa646d3c4416698f35e37ed65">rt_object_get_length</a> (enum <a class="el" href="group__group___kernel_object.html#ga38a532bcb1bd3f12685db4219b761b56">rt_object_class_type</a> type)</td></tr>
<tr class="memdesc:ga999d82dfa646d3c4416698f35e37ed65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the length of object list in object container.  <br /></td></tr>
<tr class="separator:ga999d82dfa646d3c4416698f35e37ed65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6879a7d034c9ccc56ab3a4cb8fd75f6" id="r_gaa6879a7d034c9ccc56ab3a4cb8fd75f6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#gaa6879a7d034c9ccc56ab3a4cb8fd75f6">rt_object_get_pointers</a> (enum <a class="el" href="group__group___kernel_object.html#ga38a532bcb1bd3f12685db4219b761b56">rt_object_class_type</a> type, <a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a> *pointers, int maxlen)</td></tr>
<tr class="memdesc:gaa6879a7d034c9ccc56ab3a4cb8fd75f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will copy the object pointer of the specified type, with the maximum size specified by maxlen.  <br /></td></tr>
<tr class="separator:gaa6879a7d034c9ccc56ab3a4cb8fd75f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a86356c83e8264841fcb83255f72014" id="r_ga0a86356c83e8264841fcb83255f72014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga0a86356c83e8264841fcb83255f72014">rt_object_init</a> (struct <a class="el" href="structrt__object.html">rt_object</a> *object, enum <a class="el" href="group__group___kernel_object.html#ga38a532bcb1bd3f12685db4219b761b56">rt_object_class_type</a> type, const char *name)</td></tr>
<tr class="memdesc:ga0a86356c83e8264841fcb83255f72014"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize an object and add it to object system management.  <br /></td></tr>
<tr class="separator:ga0a86356c83e8264841fcb83255f72014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3a5cf0c036738c6f0ee560a62bc93be" id="r_gad3a5cf0c036738c6f0ee560a62bc93be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#gad3a5cf0c036738c6f0ee560a62bc93be">rt_object_detach</a> (<a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a> object)</td></tr>
<tr class="memdesc:gad3a5cf0c036738c6f0ee560a62bc93be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a static object from object system, and the memory of static object is not freed.  <br /></td></tr>
<tr class="separator:gad3a5cf0c036738c6f0ee560a62bc93be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga661bb999394a29404c20c7f3e58e5f64" id="r_ga661bb999394a29404c20c7f3e58e5f64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga661bb999394a29404c20c7f3e58e5f64">rt_object_allocate</a> (enum <a class="el" href="group__group___kernel_object.html#ga38a532bcb1bd3f12685db4219b761b56">rt_object_class_type</a> type, const char *name)</td></tr>
<tr class="memdesc:ga661bb999394a29404c20c7f3e58e5f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will allocate an object from object system.  <br /></td></tr>
<tr class="separator:ga661bb999394a29404c20c7f3e58e5f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0479fb23b766d96e9611ed32becc2797" id="r_ga0479fb23b766d96e9611ed32becc2797"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga0479fb23b766d96e9611ed32becc2797">rt_object_delete</a> (<a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a> object)</td></tr>
<tr class="memdesc:ga0479fb23b766d96e9611ed32becc2797"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete an object and release object memory.  <br /></td></tr>
<tr class="separator:ga0479fb23b766d96e9611ed32becc2797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75581e85adfc9cd4068c5144d19849b4" id="r_ga75581e85adfc9cd4068c5144d19849b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga75581e85adfc9cd4068c5144d19849b4">rt_custom_object_create</a> (const char *name, void *data, <a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>(*data_destroy)(void *))</td></tr>
<tr class="separator:ga75581e85adfc9cd4068c5144d19849b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50c46982eda3aeab85fa9e2d94302d62" id="r_ga50c46982eda3aeab85fa9e2d94302d62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga50c46982eda3aeab85fa9e2d94302d62">rt_custom_object_destroy</a> (<a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a> obj)</td></tr>
<tr class="separator:ga50c46982eda3aeab85fa9e2d94302d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b4471fdda93017477bc81ca357481ac" id="r_ga0b4471fdda93017477bc81ca357481ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a3e03a3519ef7e33d13ebd34c482db49c">rt_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga0b4471fdda93017477bc81ca357481ac">rt_object_is_systemobject</a> (<a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a> object)</td></tr>
<tr class="memdesc:ga0b4471fdda93017477bc81ca357481ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will judge the object is system object or not.  <br /></td></tr>
<tr class="separator:ga0b4471fdda93017477bc81ca357481ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e9948d16704c567feb38b9d98618a91" id="r_ga8e9948d16704c567feb38b9d98618a91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga8e9948d16704c567feb38b9d98618a91">rt_object_get_type</a> (<a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a> object)</td></tr>
<tr class="memdesc:ga8e9948d16704c567feb38b9d98618a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the type of object without RT_Object_Class_Static flag.  <br /></td></tr>
<tr class="separator:ga8e9948d16704c567feb38b9d98618a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55c2a73bdf7ede3f5bb80fe70431f4f" id="r_gaa55c2a73bdf7ede3f5bb80fe70431f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#gaa55c2a73bdf7ede3f5bb80fe70431f4f">rt_object_for_each</a> (<a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> type, <a class="el" href="group__group___kernel_object.html#gacfffbe0294a95f7b0233554e3694730b">rt_object_iter_t</a> iter, void *data)</td></tr>
<tr class="memdesc:gaa55c2a73bdf7ede3f5bb80fe70431f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will iterate through each object from object container.  <br /></td></tr>
<tr class="separator:gaa55c2a73bdf7ede3f5bb80fe70431f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c82dbb4ae114918c5c96d0dca3957eb" id="r_ga6c82dbb4ae114918c5c96d0dca3957eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga6c82dbb4ae114918c5c96d0dca3957eb">rt_object_find</a> (const char *name, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> type)</td></tr>
<tr class="memdesc:ga6c82dbb4ae114918c5c96d0dca3957eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will find specified name object from object container.  <br /></td></tr>
<tr class="separator:ga6c82dbb4ae114918c5c96d0dca3957eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49942be6b9cf766f38f0ec5fe00524b2" id="r_ga49942be6b9cf766f38f0ec5fe00524b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga49942be6b9cf766f38f0ec5fe00524b2">rt_object_get_name</a> (<a class="el" href="group__group___kernel_object.html#ga91d74b4f1699da278153af455dadcd70">rt_object_t</a> object, char *name, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> name_size)</td></tr>
<tr class="memdesc:ga49942be6b9cf766f38f0ec5fe00524b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the name of the specified object container.  <br /></td></tr>
<tr class="separator:ga49942be6b9cf766f38f0ec5fe00524b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bac83f313b9fb0215c424bec05174bd" id="r_ga8bac83f313b9fb0215c424bec05174bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga8bac83f313b9fb0215c424bec05174bd">rt_object_attach_sethook</a> (void(*hook)(struct <a class="el" href="structrt__object.html">rt_object</a> *object))</td></tr>
<tr class="separator:ga8bac83f313b9fb0215c424bec05174bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28dd3af85707fc6c9bf548fe53460aca" id="r_ga28dd3af85707fc6c9bf548fe53460aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga28dd3af85707fc6c9bf548fe53460aca">rt_object_detach_sethook</a> (void(*hook)(struct <a class="el" href="structrt__object.html">rt_object</a> *object))</td></tr>
<tr class="separator:ga28dd3af85707fc6c9bf548fe53460aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfce5c06de6e1cd6b661b05cb9dd6242" id="r_gabfce5c06de6e1cd6b661b05cb9dd6242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#gabfce5c06de6e1cd6b661b05cb9dd6242">rt_object_trytake_sethook</a> (void(*hook)(struct <a class="el" href="structrt__object.html">rt_object</a> *object))</td></tr>
<tr class="separator:gabfce5c06de6e1cd6b661b05cb9dd6242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69054a027dcc8483b65fd48740eb3717" id="r_ga69054a027dcc8483b65fd48740eb3717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#ga69054a027dcc8483b65fd48740eb3717">rt_object_take_sethook</a> (void(*hook)(struct <a class="el" href="structrt__object.html">rt_object</a> *object))</td></tr>
<tr class="separator:ga69054a027dcc8483b65fd48740eb3717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad107a57fce56ef991d673fa21c6d065a" id="r_gad107a57fce56ef991d673fa21c6d065a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_object.html#gad107a57fce56ef991d673fa21c6d065a">rt_object_put_sethook</a> (void(*hook)(struct <a class="el" href="structrt__object.html">rt_object</a> *object))</td></tr>
<tr class="separator:gad107a57fce56ef991d673fa21c6d065a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e2aa36f263bddcddae01a91986fcdae" id="r_ga6e2aa36f263bddcddae01a91986fcdae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga6e2aa36f263bddcddae01a91986fcdae">rt_tick_get</a> (void)</td></tr>
<tr class="memdesc:ga6e2aa36f263bddcddae01a91986fcdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return current tick from operating system startup.  <br /></td></tr>
<tr class="separator:ga6e2aa36f263bddcddae01a91986fcdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1efb7c80c0fb0612c226f65a9ee2894c" id="r_ga1efb7c80c0fb0612c226f65a9ee2894c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga1efb7c80c0fb0612c226f65a9ee2894c">rt_tick_get_delta</a> (<a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> base)</td></tr>
<tr class="memdesc:ga1efb7c80c0fb0612c226f65a9ee2894c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return delta tick from base.  <br /></td></tr>
<tr class="separator:ga1efb7c80c0fb0612c226f65a9ee2894c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77af135da16a0b9e1c4a351f4bee6dbd" id="r_ga77af135da16a0b9e1c4a351f4bee6dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga77af135da16a0b9e1c4a351f4bee6dbd">rt_tick_set</a> (<a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> tick)</td></tr>
<tr class="memdesc:ga77af135da16a0b9e1c4a351f4bee6dbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set current tick.  <br /></td></tr>
<tr class="separator:ga77af135da16a0b9e1c4a351f4bee6dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29337f93377626f651dd393e1bb608fb" id="r_ga29337f93377626f651dd393e1bb608fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga29337f93377626f651dd393e1bb608fb">rt_tick_increase</a> (void)</td></tr>
<tr class="memdesc:ga29337f93377626f651dd393e1bb608fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will notify kernel there is one tick passed. Normally, this function is invoked by clock ISR.  <br /></td></tr>
<tr class="separator:ga29337f93377626f651dd393e1bb608fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga675d451c9e89f5aaa6e4608bab04a9ea" id="r_ga675d451c9e89f5aaa6e4608bab04a9ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga675d451c9e89f5aaa6e4608bab04a9ea">rt_tick_increase_tick</a> (<a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> tick)</td></tr>
<tr class="memdesc:ga675d451c9e89f5aaa6e4608bab04a9ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will notify kernel there is n tick passed. Normally, this function is invoked by clock ISR.  <br /></td></tr>
<tr class="separator:ga675d451c9e89f5aaa6e4608bab04a9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae158e7af4e29210a5467bc2ea93ed0d" id="r_gaae158e7af4e29210a5467bc2ea93ed0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#gaae158e7af4e29210a5467bc2ea93ed0d">rt_tick_from_millisecond</a> (<a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> ms)</td></tr>
<tr class="memdesc:gaae158e7af4e29210a5467bc2ea93ed0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will calculate the tick from millisecond.  <br /></td></tr>
<tr class="separator:gaae158e7af4e29210a5467bc2ea93ed0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad12f9ca6e5c730a0dadc7cb8a26f80a" id="r_gaad12f9ca6e5c730a0dadc7cb8a26f80a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#gaad12f9ca6e5c730a0dadc7cb8a26f80a">rt_tick_get_millisecond</a> (void)</td></tr>
<tr class="memdesc:gaad12f9ca6e5c730a0dadc7cb8a26f80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the passed millisecond from boot.  <br /></td></tr>
<tr class="separator:gaad12f9ca6e5c730a0dadc7cb8a26f80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab889b5b0b35c4c6a23b79a52098d985f" id="r_gab889b5b0b35c4c6a23b79a52098d985f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#gab889b5b0b35c4c6a23b79a52098d985f">rt_tick_sethook</a> (void(*hook)(void))</td></tr>
<tr class="separator:gab889b5b0b35c4c6a23b79a52098d985f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f109e873cdcf963059e968cedb76c36" id="r_ga9f109e873cdcf963059e968cedb76c36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga9f109e873cdcf963059e968cedb76c36">rt_system_timer_init</a> (void)</td></tr>
<tr class="memdesc:ga9f109e873cdcf963059e968cedb76c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize system timer.  <br /></td></tr>
<tr class="separator:ga9f109e873cdcf963059e968cedb76c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5298e02b109e4885723f6116fb11814" id="r_gac5298e02b109e4885723f6116fb11814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#gac5298e02b109e4885723f6116fb11814">rt_system_timer_thread_init</a> (void)</td></tr>
<tr class="memdesc:gac5298e02b109e4885723f6116fb11814"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize system timer thread.  <br /></td></tr>
<tr class="separator:gac5298e02b109e4885723f6116fb11814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga678d29f53307113da6b1578c9d3423cb" id="r_ga678d29f53307113da6b1578c9d3423cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga678d29f53307113da6b1578c9d3423cb">rt_timer_init</a> (<a class="el" href="group__group___clock.html#ga32c381b041bcb69be117bcb32273775d">rt_timer_t</a> timer, const char *name, void(*timeout)(void *parameter), void *parameter, <a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> time, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga678d29f53307113da6b1578c9d3423cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize a timer normally this function is used to initialize a static timer object.  <br /></td></tr>
<tr class="separator:ga678d29f53307113da6b1578c9d3423cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1aca4fc86f1dbd88945be8820793bb" id="r_ga0d1aca4fc86f1dbd88945be8820793bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga0d1aca4fc86f1dbd88945be8820793bb">rt_timer_detach</a> (<a class="el" href="group__group___clock.html#ga32c381b041bcb69be117bcb32273775d">rt_timer_t</a> timer)</td></tr>
<tr class="memdesc:ga0d1aca4fc86f1dbd88945be8820793bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a timer from timer management.  <br /></td></tr>
<tr class="separator:ga0d1aca4fc86f1dbd88945be8820793bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e6911989135de1b989dd7fe1b3543ce" id="r_ga9e6911989135de1b989dd7fe1b3543ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___clock.html#ga32c381b041bcb69be117bcb32273775d">rt_timer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga9e6911989135de1b989dd7fe1b3543ce">rt_timer_create</a> (const char *name, void(*timeout)(void *parameter), void *parameter, <a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> time, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga9e6911989135de1b989dd7fe1b3543ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will create a timer.  <br /></td></tr>
<tr class="separator:ga9e6911989135de1b989dd7fe1b3543ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6c147a1f25bd5ac9e72a142ab36a4ac" id="r_gaf6c147a1f25bd5ac9e72a142ab36a4ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#gaf6c147a1f25bd5ac9e72a142ab36a4ac">rt_timer_delete</a> (<a class="el" href="group__group___clock.html#ga32c381b041bcb69be117bcb32273775d">rt_timer_t</a> timer)</td></tr>
<tr class="memdesc:gaf6c147a1f25bd5ac9e72a142ab36a4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete a timer and release timer memory.  <br /></td></tr>
<tr class="separator:gaf6c147a1f25bd5ac9e72a142ab36a4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aeb8f8350b3a7403d8629231396c016" id="r_ga3aeb8f8350b3a7403d8629231396c016"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga3aeb8f8350b3a7403d8629231396c016">rt_timer_start</a> (<a class="el" href="group__group___clock.html#ga32c381b041bcb69be117bcb32273775d">rt_timer_t</a> timer)</td></tr>
<tr class="memdesc:ga3aeb8f8350b3a7403d8629231396c016"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will start the timer.  <br /></td></tr>
<tr class="separator:ga3aeb8f8350b3a7403d8629231396c016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaef9923c8b90ede02e12826c58c6f8a2" id="r_gaaef9923c8b90ede02e12826c58c6f8a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#gaaef9923c8b90ede02e12826c58c6f8a2">rt_timer_stop</a> (<a class="el" href="group__group___clock.html#ga32c381b041bcb69be117bcb32273775d">rt_timer_t</a> timer)</td></tr>
<tr class="memdesc:gaaef9923c8b90ede02e12826c58c6f8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will stop the timer.  <br /></td></tr>
<tr class="separator:gaaef9923c8b90ede02e12826c58c6f8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e3b76a4a58d31aaf5c992bc127615c" id="r_ga15e3b76a4a58d31aaf5c992bc127615c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga15e3b76a4a58d31aaf5c992bc127615c">rt_timer_control</a> (<a class="el" href="group__group___clock.html#ga32c381b041bcb69be117bcb32273775d">rt_timer_t</a> timer, int cmd, void *arg)</td></tr>
<tr class="memdesc:ga15e3b76a4a58d31aaf5c992bc127615c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will get or set some options of the timer.  <br /></td></tr>
<tr class="separator:ga15e3b76a4a58d31aaf5c992bc127615c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51af0ff7d55ff298adfb87d276d0d678" id="r_ga51af0ff7d55ff298adfb87d276d0d678"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga51af0ff7d55ff298adfb87d276d0d678">rt_timer_next_timeout_tick</a> (void)</td></tr>
<tr class="memdesc:ga51af0ff7d55ff298adfb87d276d0d678"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the next timeout tick in the system.  <br /></td></tr>
<tr class="separator:ga51af0ff7d55ff298adfb87d276d0d678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a29a70b401aa9d5c5dbb7269fd0ac57" id="r_ga3a29a70b401aa9d5c5dbb7269fd0ac57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga3a29a70b401aa9d5c5dbb7269fd0ac57">rt_timer_check</a> (void)</td></tr>
<tr class="memdesc:ga3a29a70b401aa9d5c5dbb7269fd0ac57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will check timer list, if a timeout event happens, the corresponding timeout function will be invoked.  <br /></td></tr>
<tr class="separator:ga3a29a70b401aa9d5c5dbb7269fd0ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga639bcf43fc3737d2c6a76d7c3f4f9414" id="r_ga639bcf43fc3737d2c6a76d7c3f4f9414"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga639bcf43fc3737d2c6a76d7c3f4f9414">rt_timer_enter_sethook</a> (void(*hook)(struct <a class="el" href="structrt__timer.html">rt_timer</a> *timer))</td></tr>
<tr class="separator:ga639bcf43fc3737d2c6a76d7c3f4f9414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9452b8224df3575c9c5314ed4a3518" id="r_ga1a9452b8224df3575c9c5314ed4a3518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___clock.html#ga1a9452b8224df3575c9c5314ed4a3518">rt_timer_exit_sethook</a> (void(*hook)(struct <a class="el" href="structrt__timer.html">rt_timer</a> *timer))</td></tr>
<tr class="separator:ga1a9452b8224df3575c9c5314ed4a3518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd985aa60939b95e510f144610f001b9" id="r_gacd985aa60939b95e510f144610f001b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gacd985aa60939b95e510f144610f001b9">rt_thread_init</a> (struct <a class="el" href="structrt__thread.html">rt_thread</a> *thread, const char *name, void(*entry)(void *parameter), void *parameter, void *stack_start, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> stack_size, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> priority, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> tick)</td></tr>
<tr class="memdesc:gacd985aa60939b95e510f144610f001b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize a thread. It's used to initialize a static thread object.  <br /></td></tr>
<tr class="separator:gacd985aa60939b95e510f144610f001b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga514825b80304477ecf377d721da409b0" id="r_ga514825b80304477ecf377d721da409b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga514825b80304477ecf377d721da409b0">rt_thread_detach</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:ga514825b80304477ecf377d721da409b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a thread. The thread object will be removed from thread queue and detached/deleted from the system object management.  <br /></td></tr>
<tr class="separator:ga514825b80304477ecf377d721da409b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb215b161f17c26b5e19c28cd0119e7b" id="r_gacb215b161f17c26b5e19c28cd0119e7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gacb215b161f17c26b5e19c28cd0119e7b">rt_thread_create</a> (const char *name, void(*entry)(void *parameter), void *parameter, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> stack_size, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> priority, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> tick)</td></tr>
<tr class="memdesc:gacb215b161f17c26b5e19c28cd0119e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will create a thread object and allocate thread object memory. and stack.  <br /></td></tr>
<tr class="separator:gacb215b161f17c26b5e19c28cd0119e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d64eb4d0a485461049616808f4ce177" id="r_ga6d64eb4d0a485461049616808f4ce177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga6d64eb4d0a485461049616808f4ce177">rt_thread_delete</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:ga6d64eb4d0a485461049616808f4ce177"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete a thread. The thread object will be removed from thread queue and deleted from system object management in the idle thread.  <br /></td></tr>
<tr class="separator:ga6d64eb4d0a485461049616808f4ce177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c482e895baff359b920966f2822ee06" id="r_ga0c482e895baff359b920966f2822ee06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga0c482e895baff359b920966f2822ee06">rt_thread_close</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:ga0c482e895baff359b920966f2822ee06"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will close a thread. The thread object will be removed from thread queue and detached/deleted from the system object management. It's different from rt_thread_delete or rt_thread_detach that this will not enqueue the closing thread to cleanup queue.  <br /></td></tr>
<tr class="separator:ga0c482e895baff359b920966f2822ee06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6133c1b6b27d972447156db15e7c1ce7" id="r_ga6133c1b6b27d972447156db15e7c1ce7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga6133c1b6b27d972447156db15e7c1ce7">rt_thread_self</a> (void)</td></tr>
<tr class="memdesc:ga6133c1b6b27d972447156db15e7c1ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return self thread object.  <br /></td></tr>
<tr class="separator:ga6133c1b6b27d972447156db15e7c1ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga789a0782597b4d7f7c6c16eacc6084a8" id="r_ga789a0782597b4d7f7c6c16eacc6084a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga789a0782597b4d7f7c6c16eacc6084a8">rt_thread_find</a> (char *name)</td></tr>
<tr class="memdesc:ga789a0782597b4d7f7c6c16eacc6084a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will find the specified thread.  <br /></td></tr>
<tr class="separator:ga789a0782597b4d7f7c6c16eacc6084a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04b743537fd099e204fc292e57b4aa5a" id="r_ga04b743537fd099e204fc292e57b4aa5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga04b743537fd099e204fc292e57b4aa5a">rt_thread_startup</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:ga04b743537fd099e204fc292e57b4aa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will start a thread and put it to system ready queue.  <br /></td></tr>
<tr class="separator:ga04b743537fd099e204fc292e57b4aa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5703a0d7351b37a1c00874a362626ea3" id="r_ga5703a0d7351b37a1c00874a362626ea3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga5703a0d7351b37a1c00874a362626ea3">rt_thread_yield</a> (void)</td></tr>
<tr class="memdesc:ga5703a0d7351b37a1c00874a362626ea3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will let current thread yield processor, and scheduler will choose the highest thread to run. After yield processor, the current thread is still in READY state.  <br /></td></tr>
<tr class="separator:ga5703a0d7351b37a1c00874a362626ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b18459cac67e3695447e69b997fc74e" id="r_ga6b18459cac67e3695447e69b997fc74e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga6b18459cac67e3695447e69b997fc74e">rt_thread_delay</a> (<a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> tick)</td></tr>
<tr class="memdesc:ga6b18459cac67e3695447e69b997fc74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will let current thread delay for some ticks.  <br /></td></tr>
<tr class="separator:ga6b18459cac67e3695447e69b997fc74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga309d01453eb09acaee5012a2e159961c" id="r_ga309d01453eb09acaee5012a2e159961c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga309d01453eb09acaee5012a2e159961c">rt_thread_delay_until</a> (<a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> *tick, <a class="el" href="rttypes_8h.html#a66c400929925784dba020d671154978a">rt_tick_t</a> inc_tick)</td></tr>
<tr class="memdesc:ga309d01453eb09acaee5012a2e159961c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will let current thread delay until (*tick + inc_tick).  <br /></td></tr>
<tr class="separator:ga309d01453eb09acaee5012a2e159961c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ba0dbf06d5fa05f469da371ff6d2876" id="r_ga4ba0dbf06d5fa05f469da371ff6d2876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga4ba0dbf06d5fa05f469da371ff6d2876">rt_thread_mdelay</a> (<a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> ms)</td></tr>
<tr class="memdesc:ga4ba0dbf06d5fa05f469da371ff6d2876"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will let current thread delay for some milliseconds.  <br /></td></tr>
<tr class="separator:ga4ba0dbf06d5fa05f469da371ff6d2876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34c65d3f7d01310fe7b54b2e706b1bdc" id="r_ga34c65d3f7d01310fe7b54b2e706b1bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga34c65d3f7d01310fe7b54b2e706b1bdc">rt_thread_control</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread, int cmd, void *arg)</td></tr>
<tr class="memdesc:ga34c65d3f7d01310fe7b54b2e706b1bdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will control thread behaviors according to control command.  <br /></td></tr>
<tr class="separator:ga34c65d3f7d01310fe7b54b2e706b1bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab75228a43588dc35570bce6a2c18f3f0" id="r_gab75228a43588dc35570bce6a2c18f3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gab75228a43588dc35570bce6a2c18f3f0">rt_thread_suspend</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="separator:gab75228a43588dc35570bce6a2c18f3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga537adfa695f87cdea6310ec3f66fced0" id="r_ga537adfa695f87cdea6310ec3f66fced0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga537adfa695f87cdea6310ec3f66fced0">rt_thread_suspend_with_flag</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread, int suspend_flag)</td></tr>
<tr class="memdesc:ga537adfa695f87cdea6310ec3f66fced0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will suspend the specified thread and change it to suspend state.  <br /></td></tr>
<tr class="separator:ga537adfa695f87cdea6310ec3f66fced0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4f29aff4fec96d92f6321fa7b00c379" id="r_gab4f29aff4fec96d92f6321fa7b00c379"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gab4f29aff4fec96d92f6321fa7b00c379">rt_thread_resume</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:gab4f29aff4fec96d92f6321fa7b00c379"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will resume a thread and put it to system ready queue.  <br /></td></tr>
<tr class="separator:gab4f29aff4fec96d92f6321fa7b00c379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2474c7ee1c6eb90f676ecbbc904363" id="r_ga0e2474c7ee1c6eb90f676ecbbc904363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga0e2474c7ee1c6eb90f676ecbbc904363">rt_thread_get_name</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread, char *name, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> name_size)</td></tr>
<tr class="memdesc:ga0e2474c7ee1c6eb90f676ecbbc904363"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the name of the specified thread.  <br /></td></tr>
<tr class="separator:ga0e2474c7ee1c6eb90f676ecbbc904363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c6bd85fb0e9179bfbb1b176539d097f" id="r_ga4c6bd85fb0e9179bfbb1b176539d097f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga4c6bd85fb0e9179bfbb1b176539d097f">rt_thread_alloc_sig</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> tid)</td></tr>
<tr class="separator:ga4c6bd85fb0e9179bfbb1b176539d097f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d7cbacfe5c3634d14f8e12bb558184a" id="r_ga8d7cbacfe5c3634d14f8e12bb558184a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga8d7cbacfe5c3634d14f8e12bb558184a">rt_thread_free_sig</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> tid)</td></tr>
<tr class="separator:ga8d7cbacfe5c3634d14f8e12bb558184a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2135a51adac8206aa7876466ae00ee20" id="r_ga2135a51adac8206aa7876466ae00ee20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga2135a51adac8206aa7876466ae00ee20">rt_thread_kill</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> tid, int sig)</td></tr>
<tr class="memdesc:ga2135a51adac8206aa7876466ae00ee20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can be used to send any signal to any thread.  <br /></td></tr>
<tr class="separator:ga2135a51adac8206aa7876466ae00ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83bae9e21b23cfbf2e1c4f09654e3012" id="r_ga83bae9e21b23cfbf2e1c4f09654e3012"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga83bae9e21b23cfbf2e1c4f09654e3012">rt_thread_suspend_sethook</a> (void(*hook)(<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread))</td></tr>
<tr class="separator:ga83bae9e21b23cfbf2e1c4f09654e3012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae051e428ad5b79744249d2658d5084b5" id="r_gae051e428ad5b79744249d2658d5084b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gae051e428ad5b79744249d2658d5084b5">rt_thread_resume_sethook</a> (void(*hook)(<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread))</td></tr>
<tr class="separator:gae051e428ad5b79744249d2658d5084b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64f2c17d6cef710eb12414f23640116a" id="r_ga64f2c17d6cef710eb12414f23640116a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga64f2c17d6cef710eb12414f23640116a">RT_OBJECT_HOOKLIST_DECLARE</a> (<a class="el" href="group__group___thread.html#ga7834be0d0c62aaa32ae47ade3ac21e68">rt_thread_inited_hookproto_t</a>, rt_thread_inited)</td></tr>
<tr class="separator:ga64f2c17d6cef710eb12414f23640116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0dcacf89c3d97272b185f7162a3e0c3" id="r_gae0dcacf89c3d97272b185f7162a3e0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gae0dcacf89c3d97272b185f7162a3e0c3">rt_thread_idle_init</a> (void)</td></tr>
<tr class="memdesc:gae0dcacf89c3d97272b185f7162a3e0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize idle thread, then start it.  <br /></td></tr>
<tr class="separator:gae0dcacf89c3d97272b185f7162a3e0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab943d93390d71c999debbf98fee44a0e" id="r_gab943d93390d71c999debbf98fee44a0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gab943d93390d71c999debbf98fee44a0e">rt_thread_idle_sethook</a> (void(*hook)(void))</td></tr>
<tr class="separator:gab943d93390d71c999debbf98fee44a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf48521904309636f9ccdbf562199c0a5" id="r_gaf48521904309636f9ccdbf562199c0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gaf48521904309636f9ccdbf562199c0a5">rt_thread_idle_delhook</a> (void(*hook)(void))</td></tr>
<tr class="memdesc:gaf48521904309636f9ccdbf562199c0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the idle hook on hook list.  <br /></td></tr>
<tr class="separator:gaf48521904309636f9ccdbf562199c0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd22f9965fffe9e940fd364f0838731f" id="r_gadd22f9965fffe9e940fd364f0838731f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gadd22f9965fffe9e940fd364f0838731f">rt_thread_idle_gethandler</a> (void)</td></tr>
<tr class="memdesc:gadd22f9965fffe9e940fd364f0838731f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will get the handler of the idle thread.  <br /></td></tr>
<tr class="separator:gadd22f9965fffe9e940fd364f0838731f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aa2c0c67999e20ce8693ad3c8e624f0" id="r_ga5aa2c0c67999e20ce8693ad3c8e624f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga5aa2c0c67999e20ce8693ad3c8e624f0">rt_system_scheduler_init</a> (void)</td></tr>
<tr class="memdesc:ga5aa2c0c67999e20ce8693ad3c8e624f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the system scheduler.  <br /></td></tr>
<tr class="separator:ga5aa2c0c67999e20ce8693ad3c8e624f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9aa8a561e0caf5e13126834c4f4bb681" id="r_ga9aa8a561e0caf5e13126834c4f4bb681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga9aa8a561e0caf5e13126834c4f4bb681">rt_system_scheduler_start</a> (void)</td></tr>
<tr class="memdesc:ga9aa8a561e0caf5e13126834c4f4bb681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the system scheduler and switch to the highest priority thread.  <br /></td></tr>
<tr class="separator:ga9aa8a561e0caf5e13126834c4f4bb681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9f99bb5e2e2032b10ddda7a03eefe24" id="r_gae9f99bb5e2e2032b10ddda7a03eefe24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gae9f99bb5e2e2032b10ddda7a03eefe24">rt_schedule</a> (void)</td></tr>
<tr class="separator:gae9f99bb5e2e2032b10ddda7a03eefe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb4158a39c5ea956a96b22190ce0ed89" id="r_gabb4158a39c5ea956a96b22190ce0ed89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gabb4158a39c5ea956a96b22190ce0ed89">rt_scheduler_do_irq_switch</a> (void *context)</td></tr>
<tr class="separator:gabb4158a39c5ea956a96b22190ce0ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76da2e5b2bc5193a710491a6b2cbbff6" id="r_ga76da2e5b2bc5193a710491a6b2cbbff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a0903689e9212375ba7d0de65c3adfece">rt_base_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga76da2e5b2bc5193a710491a6b2cbbff6">rt_enter_critical</a> (void)</td></tr>
<tr class="separator:ga76da2e5b2bc5193a710491a6b2cbbff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35c56c2d56e2bb0f2df95abc752143df" id="r_ga35c56c2d56e2bb0f2df95abc752143df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga35c56c2d56e2bb0f2df95abc752143df">rt_exit_critical</a> (void)</td></tr>
<tr class="separator:ga35c56c2d56e2bb0f2df95abc752143df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28198f1a056fd2b1289b574641324d02" id="r_ga28198f1a056fd2b1289b574641324d02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga28198f1a056fd2b1289b574641324d02">rt_exit_critical_safe</a> (<a class="el" href="rttypes_8h.html#a0903689e9212375ba7d0de65c3adfece">rt_base_t</a> critical_level)</td></tr>
<tr class="separator:ga28198f1a056fd2b1289b574641324d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f894e8efadefda238a5e5ab45c7e21" id="r_gaf3f894e8efadefda238a5e5ab45c7e21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a5acba55f46553417996ac70828b874da">rt_uint16_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#gaf3f894e8efadefda238a5e5ab45c7e21">rt_critical_level</a> (void)</td></tr>
<tr class="separator:gaf3f894e8efadefda238a5e5ab45c7e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af67d388db8019327b5f86428e2ed14" id="r_ga1af67d388db8019327b5f86428e2ed14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga1af67d388db8019327b5f86428e2ed14">rt_scheduler_sethook</a> (void(*hook)(<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> from, <a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> to))</td></tr>
<tr class="separator:ga1af67d388db8019327b5f86428e2ed14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4685884789cfcd32a5a7626184cb4d7b" id="r_ga4685884789cfcd32a5a7626184cb4d7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___thread.html#ga4685884789cfcd32a5a7626184cb4d7b">rt_scheduler_switch_sethook</a> (void(*hook)(struct <a class="el" href="structrt__thread.html">rt_thread</a> *tid))</td></tr>
<tr class="separator:ga4685884789cfcd32a5a7626184cb4d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5b9d9d71c646bc197061740086bea1" id="r_gadf5b9d9d71c646bc197061740086bea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___signal.html#gadf5b9d9d71c646bc197061740086bea1">rt_signal_mask</a> (int signo)</td></tr>
<tr class="memdesc:gadf5b9d9d71c646bc197061740086bea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will block the specified signal.  <br /></td></tr>
<tr class="separator:gadf5b9d9d71c646bc197061740086bea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1a87673979f0f998291e4d2e23f84f" id="r_ga4a1a87673979f0f998291e4d2e23f84f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___signal.html#ga4a1a87673979f0f998291e4d2e23f84f">rt_signal_unmask</a> (int signo)</td></tr>
<tr class="memdesc:ga4a1a87673979f0f998291e4d2e23f84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will unblock the specified signal.  <br /></td></tr>
<tr class="separator:ga4a1a87673979f0f998291e4d2e23f84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e1a5361753ba8456157840220014f08" id="r_ga1e1a5361753ba8456157840220014f08"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___signal.html#ga1e1a5361753ba8456157840220014f08">rt_signal_check</a> (void *context)</td></tr>
<tr class="separator:ga1e1a5361753ba8456157840220014f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55baee131d10ccb32bec3f8bec93e461" id="r_ga55baee131d10ccb32bec3f8bec93e461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___signal.html#gadb4d59c0df16a522a0a847d5257bb208">rt_sighandler_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___signal.html#ga55baee131d10ccb32bec3f8bec93e461">rt_signal_install</a> (int signo, <a class="el" href="group__group___signal.html#gadb4d59c0df16a522a0a847d5257bb208">rt_sighandler_t</a> handler)</td></tr>
<tr class="memdesc:ga55baee131d10ccb32bec3f8bec93e461"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will install a processing function to a specific signal and return the old processing function of this signal.  <br /></td></tr>
<tr class="separator:ga55baee131d10ccb32bec3f8bec93e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef728f0d33d2ba37a164d121337d37a6" id="r_gaef728f0d33d2ba37a164d121337d37a6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___signal.html#gaef728f0d33d2ba37a164d121337d37a6">rt_signal_wait</a> (const <a class="el" href="group__group___signal.html#ga7868cb7a1f4b5659f7b6f5482b77f689">rt_sigset_t</a> *set, <a class="el" href="group__group___signal.html#ga032d2a90cfb47b98f7cffdf0c924b254">rt_siginfo_t</a> *si, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="memdesc:gaef728f0d33d2ba37a164d121337d37a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will wait for the arrival of the set signal. If it does not wait for this signal, the thread will be suspended until it waits for this signal or the waiting time exceeds the specified timeout: timeout.  <br /></td></tr>
<tr class="separator:gaef728f0d33d2ba37a164d121337d37a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67e8cf26cc3f6c731bd394786e7adf7c" id="r_ga67e8cf26cc3f6c731bd394786e7adf7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___signal.html#ga67e8cf26cc3f6c731bd394786e7adf7c">rt_system_signal_init</a> (void)</td></tr>
<tr class="separator:ga67e8cf26cc3f6c731bd394786e7adf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a6bc99e5cb8663be2f1882410448f94" id="r_ga1a6bc99e5cb8663be2f1882410448f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga1a6bc99e5cb8663be2f1882410448f94">rt_mp_init</a> (struct <a class="el" href="structrt__mempool.html">rt_mempool</a> *mp, const char *name, void *start, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> block_size)</td></tr>
<tr class="memdesc:ga1a6bc99e5cb8663be2f1882410448f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize a memory pool object, normally which is used for static object.  <br /></td></tr>
<tr class="separator:ga1a6bc99e5cb8663be2f1882410448f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65fc7bef71be142744e517eebe13fc04" id="r_ga65fc7bef71be142744e517eebe13fc04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga65fc7bef71be142744e517eebe13fc04">rt_mp_detach</a> (struct <a class="el" href="structrt__mempool.html">rt_mempool</a> *mp)</td></tr>
<tr class="memdesc:ga65fc7bef71be142744e517eebe13fc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a memory pool from system object management.  <br /></td></tr>
<tr class="separator:ga65fc7bef71be142744e517eebe13fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe8c74161a1d6f456e67efb2c16195b7" id="r_gabe8c74161a1d6f456e67efb2c16195b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___m_m.html#gacd1967553fa041da8c8bf22d4a8b1c30">rt_mp_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gabe8c74161a1d6f456e67efb2c16195b7">rt_mp_create</a> (const char *name, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> block_count, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> block_size)</td></tr>
<tr class="memdesc:gabe8c74161a1d6f456e67efb2c16195b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will create a mempool object and allocate the memory pool from heap.  <br /></td></tr>
<tr class="separator:gabe8c74161a1d6f456e67efb2c16195b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1b1218858d5ec8a95be226ae897f26" id="r_gace1b1218858d5ec8a95be226ae897f26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gace1b1218858d5ec8a95be226ae897f26">rt_mp_delete</a> (<a class="el" href="group__group___m_m.html#gacd1967553fa041da8c8bf22d4a8b1c30">rt_mp_t</a> mp)</td></tr>
<tr class="memdesc:gace1b1218858d5ec8a95be226ae897f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete a memory pool and release the object memory.  <br /></td></tr>
<tr class="separator:gace1b1218858d5ec8a95be226ae897f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga531984d42851ffa0fd7a14bf67f15c22" id="r_ga531984d42851ffa0fd7a14bf67f15c22"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga531984d42851ffa0fd7a14bf67f15c22">rt_mp_alloc</a> (<a class="el" href="group__group___m_m.html#gacd1967553fa041da8c8bf22d4a8b1c30">rt_mp_t</a> mp, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> time)</td></tr>
<tr class="memdesc:ga531984d42851ffa0fd7a14bf67f15c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will allocate a block from memory pool.  <br /></td></tr>
<tr class="separator:ga531984d42851ffa0fd7a14bf67f15c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65371665abde3bed7379c72d5ea225e2" id="r_ga65371665abde3bed7379c72d5ea225e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga65371665abde3bed7379c72d5ea225e2">rt_mp_free</a> (void *block)</td></tr>
<tr class="memdesc:ga65371665abde3bed7379c72d5ea225e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will release a memory block.  <br /></td></tr>
<tr class="separator:ga65371665abde3bed7379c72d5ea225e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga358d3559267d1c8c66c836ed2e08433b" id="r_ga358d3559267d1c8c66c836ed2e08433b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga358d3559267d1c8c66c836ed2e08433b">rt_mp_alloc_sethook</a> (void(*hook)(struct <a class="el" href="structrt__mempool.html">rt_mempool</a> *mp, void *block))</td></tr>
<tr class="separator:ga358d3559267d1c8c66c836ed2e08433b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd43b13db5623925756b7a3968aa3b01" id="r_gafd43b13db5623925756b7a3968aa3b01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gafd43b13db5623925756b7a3968aa3b01">rt_mp_free_sethook</a> (void(*hook)(struct <a class="el" href="structrt__mempool.html">rt_mempool</a> *mp, void *block))</td></tr>
<tr class="separator:gafd43b13db5623925756b7a3968aa3b01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa6feb60f6204d1783bc3bc324b886e7" id="r_gafa6feb60f6204d1783bc3bc324b886e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gafa6feb60f6204d1783bc3bc324b886e7">rt_system_heap_init</a> (void *begin_addr, void *end_addr)</td></tr>
<tr class="memdesc:gafa6feb60f6204d1783bc3bc324b886e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will init system heap. User can override this API to complete other works, like heap sanitizer initialization.  <br /></td></tr>
<tr class="separator:gafa6feb60f6204d1783bc3bc324b886e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70655467791a07c7da77f184914a580" id="r_gaf70655467791a07c7da77f184914a580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gaf70655467791a07c7da77f184914a580">rt_system_heap_init_generic</a> (void *begin_addr, void *end_addr)</td></tr>
<tr class="memdesc:gaf70655467791a07c7da77f184914a580"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will do the generic system heap initialization.  <br /></td></tr>
<tr class="separator:gaf70655467791a07c7da77f184914a580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f19fbf07d6cf7ac5c91af52352644f6" id="r_ga6f19fbf07d6cf7ac5c91af52352644f6"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga6f19fbf07d6cf7ac5c91af52352644f6">rt_malloc</a> (<a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="memdesc:ga6f19fbf07d6cf7ac5c91af52352644f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory with a minimum of 'size' bytes.  <br /></td></tr>
<tr class="separator:ga6f19fbf07d6cf7ac5c91af52352644f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c1c24262479e6946fd04823878177f9" id="r_ga6c1c24262479e6946fd04823878177f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga6c1c24262479e6946fd04823878177f9">rt_free</a> (void *ptr)</td></tr>
<tr class="memdesc:ga6c1c24262479e6946fd04823878177f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will release the previously allocated memory block by rt_malloc. The released memory block is taken back to system heap.  <br /></td></tr>
<tr class="separator:ga6c1c24262479e6946fd04823878177f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b2fb264e7eb28d173c0fce864fe7e43" id="r_ga9b2fb264e7eb28d173c0fce864fe7e43"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga9b2fb264e7eb28d173c0fce864fe7e43">rt_realloc</a> (void *ptr, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> newsize)</td></tr>
<tr class="memdesc:ga9b2fb264e7eb28d173c0fce864fe7e43"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will change the size of previously allocated memory block.  <br /></td></tr>
<tr class="separator:ga9b2fb264e7eb28d173c0fce864fe7e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89c02c2964ca603cf87912871bafa1b4" id="r_ga89c02c2964ca603cf87912871bafa1b4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga89c02c2964ca603cf87912871bafa1b4">rt_calloc</a> (<a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> count, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="memdesc:ga89c02c2964ca603cf87912871bafa1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will contiguously allocate enough space for count objects that are size bytes of memory each and returns a pointer to the allocated memory.  <br /></td></tr>
<tr class="separator:ga89c02c2964ca603cf87912871bafa1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dc9ac8a12cf36f08d0a3ebf7fe9ce4e" id="r_ga1dc9ac8a12cf36f08d0a3ebf7fe9ce4e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga1dc9ac8a12cf36f08d0a3ebf7fe9ce4e">rt_malloc_align</a> (<a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> align)</td></tr>
<tr class="memdesc:ga1dc9ac8a12cf36f08d0a3ebf7fe9ce4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function allocates a memory block, which address is aligned to the specified alignment size.  <br /></td></tr>
<tr class="separator:ga1dc9ac8a12cf36f08d0a3ebf7fe9ce4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1ea8f43781620e7b08fb1868e32b92" id="r_gabf1ea8f43781620e7b08fb1868e32b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gabf1ea8f43781620e7b08fb1868e32b92">rt_free_align</a> (void *ptr)</td></tr>
<tr class="memdesc:gabf1ea8f43781620e7b08fb1868e32b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function release the memory block, which is allocated by rt_malloc_align function and address is aligned.  <br /></td></tr>
<tr class="separator:gabf1ea8f43781620e7b08fb1868e32b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a043ee84954692789696a255ea65699" id="r_ga6a043ee84954692789696a255ea65699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga6a043ee84954692789696a255ea65699">rt_memory_info</a> (<a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> *total, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> *used, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> *max_used)</td></tr>
<tr class="memdesc:ga6a043ee84954692789696a255ea65699"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will caculate the total memory, the used memory, and the max used memory.  <br /></td></tr>
<tr class="separator:ga6a043ee84954692789696a255ea65699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3ee8887d4ace66606a925237e199ad6" id="r_gaf3ee8887d4ace66606a925237e199ad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___m_m.html#ga4880147b2aef9d5e2be045a998d9d4b3">rt_smem_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gaf3ee8887d4ace66606a925237e199ad6">rt_smem_init</a> (const char *name, void *begin_addr, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="memdesc:gaf3ee8887d4ace66606a925237e199ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize small memory management algorithm.  <br /></td></tr>
<tr class="separator:gaf3ee8887d4ace66606a925237e199ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf444d6040e6a1ef09ab9f95e893b8d40" id="r_gaf444d6040e6a1ef09ab9f95e893b8d40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gaf444d6040e6a1ef09ab9f95e893b8d40">rt_smem_detach</a> (<a class="el" href="group__group___m_m.html#ga4880147b2aef9d5e2be045a998d9d4b3">rt_smem_t</a> m)</td></tr>
<tr class="memdesc:gaf444d6040e6a1ef09ab9f95e893b8d40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will remove a small mem from the system.  <br /></td></tr>
<tr class="separator:gaf444d6040e6a1ef09ab9f95e893b8d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80448818ad067205d76e94f8c97e5fe9" id="r_ga80448818ad067205d76e94f8c97e5fe9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga80448818ad067205d76e94f8c97e5fe9">rt_smem_alloc</a> (<a class="el" href="group__group___m_m.html#ga4880147b2aef9d5e2be045a998d9d4b3">rt_smem_t</a> m, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="memdesc:ga80448818ad067205d76e94f8c97e5fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate a block of memory with a minimum of 'size' bytes.  <br /></td></tr>
<tr class="separator:ga80448818ad067205d76e94f8c97e5fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3db5c0cc04b7a3e1d06c2a6da2e6d5c" id="r_gab3db5c0cc04b7a3e1d06c2a6da2e6d5c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#gab3db5c0cc04b7a3e1d06c2a6da2e6d5c">rt_smem_realloc</a> (<a class="el" href="group__group___m_m.html#ga4880147b2aef9d5e2be045a998d9d4b3">rt_smem_t</a> m, void *rmem, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> newsize)</td></tr>
<tr class="memdesc:gab3db5c0cc04b7a3e1d06c2a6da2e6d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will change the size of previously allocated memory block.  <br /></td></tr>
<tr class="separator:gab3db5c0cc04b7a3e1d06c2a6da2e6d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be498288489171f107c04ed44314ef0" id="r_ga0be498288489171f107c04ed44314ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga0be498288489171f107c04ed44314ef0">rt_smem_free</a> (void *rmem)</td></tr>
<tr class="memdesc:ga0be498288489171f107c04ed44314ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will release the previously allocated memory block by rt_mem_alloc. The released memory block is taken back to system heap.  <br /></td></tr>
<tr class="separator:ga0be498288489171f107c04ed44314ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d606cce2b6cd26472b812d88db85000" id="r_ga8d606cce2b6cd26472b812d88db85000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga8d606cce2b6cd26472b812d88db85000">rt_susp_list_print</a> (<a class="el" href="rttypes_8h.html#a8e0e590336e9435f976bf672d844547c">rt_list_t</a> *list)</td></tr>
<tr class="memdesc:ga8d606cce2b6cd26472b812d88db85000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print thread on suspend list to system console.  <br /></td></tr>
<tr class="separator:ga8d606cce2b6cd26472b812d88db85000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb76b2b1161287a7be42f2478d500e6" id="r_gadcb76b2b1161287a7be42f2478d500e6"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrt__thread.html">rt_thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#gadcb76b2b1161287a7be42f2478d500e6">rt_susp_list_dequeue</a> (<a class="el" href="rttypes_8h.html#a8e0e590336e9435f976bf672d844547c">rt_list_t</a> *susp_list, <a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a> thread_error)</td></tr>
<tr class="memdesc:gadcb76b2b1161287a7be42f2478d500e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue a thread from suspended list and set it to ready. The 2 are taken as an atomic operation, so if a thread is returned, it's resumed by us, not any other threads or async events. This is useful if a consumer may be resumed by timeout, signals... besides its producer.  <br /></td></tr>
<tr class="separator:gadcb76b2b1161287a7be42f2478d500e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47f20344c3dd0c5b468a22d03be40458" id="r_ga47f20344c3dd0c5b468a22d03be40458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga47f20344c3dd0c5b468a22d03be40458">rt_susp_list_resume_all</a> (<a class="el" href="rttypes_8h.html#a8e0e590336e9435f976bf672d844547c">rt_list_t</a> *susp_list, <a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a> thread_error)</td></tr>
<tr class="memdesc:ga47f20344c3dd0c5b468a22d03be40458"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will resume all suspended threads in the IPC object list, including the suspended list of IPC object, and private list of mailbox etc.  <br /></td></tr>
<tr class="separator:ga47f20344c3dd0c5b468a22d03be40458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d699e6dc7d4de6b2613de11791619f3" id="r_ga3d699e6dc7d4de6b2613de11791619f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga3d699e6dc7d4de6b2613de11791619f3">rt_susp_list_resume_all_irq</a> (<a class="el" href="rttypes_8h.html#a8e0e590336e9435f976bf672d844547c">rt_list_t</a> *susp_list, <a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a> thread_error, struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *lock)</td></tr>
<tr class="memdesc:ga3d699e6dc7d4de6b2613de11791619f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will resume all suspended threads in the IPC object list, including the suspended list of IPC object, and private list of mailbox etc. A lock is passing and hold while operating.  <br /></td></tr>
<tr class="separator:ga3d699e6dc7d4de6b2613de11791619f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e560062d5e4b929ad2868e4ccc90f2" id="r_ga41e560062d5e4b929ad2868e4ccc90f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga41e560062d5e4b929ad2868e4ccc90f2">rt_thread_suspend_to_list</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread, <a class="el" href="rttypes_8h.html#a8e0e590336e9435f976bf672d844547c">rt_list_t</a> *susp_list, int ipc_flags, int suspend_flag)</td></tr>
<tr class="memdesc:ga41e560062d5e4b929ad2868e4ccc90f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will suspend the specified thread and change it to suspend state.  <br /></td></tr>
<tr class="separator:ga41e560062d5e4b929ad2868e4ccc90f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadeac06fe647458b336572c4e6464c30d" id="r_gadeac06fe647458b336572c4e6464c30d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#gadeac06fe647458b336572c4e6464c30d">rt_susp_list_enqueue</a> (<a class="el" href="rttypes_8h.html#a8e0e590336e9435f976bf672d844547c">rt_list_t</a> *susp_list, <a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread, int ipc_flags)</td></tr>
<tr class="memdesc:gadeac06fe647458b336572c4e6464c30d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a thread to the suspend list.  <br /></td></tr>
<tr class="separator:gadeac06fe647458b336572c4e6464c30d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga023e00dd1ae86ddbeb2dbf92771e17ea" id="r_ga023e00dd1ae86ddbeb2dbf92771e17ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#ga023e00dd1ae86ddbeb2dbf92771e17ea">rt_sem_init</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem, const char *name, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> value, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga023e00dd1ae86ddbeb2dbf92771e17ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will initialize a static semaphore object.  <br /></td></tr>
<tr class="separator:ga023e00dd1ae86ddbeb2dbf92771e17ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd3560a50be21e132c71f622870c500" id="r_ga7dd3560a50be21e132c71f622870c500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#ga7dd3560a50be21e132c71f622870c500">rt_sem_detach</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem)</td></tr>
<tr class="memdesc:ga7dd3560a50be21e132c71f622870c500"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a static semaphore object.  <br /></td></tr>
<tr class="separator:ga7dd3560a50be21e132c71f622870c500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a4960ff4a173f1d1c35ede42e1227f" id="r_ga61a4960ff4a173f1d1c35ede42e1227f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#ga61a4960ff4a173f1d1c35ede42e1227f">rt_sem_create</a> (const char *name, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> value, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga61a4960ff4a173f1d1c35ede42e1227f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a semaphore object.  <br /></td></tr>
<tr class="separator:ga61a4960ff4a173f1d1c35ede42e1227f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e45d2b96aab649832b6756d68629bbe" id="r_ga0e45d2b96aab649832b6756d68629bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#ga0e45d2b96aab649832b6756d68629bbe">rt_sem_delete</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem)</td></tr>
<tr class="memdesc:ga0e45d2b96aab649832b6756d68629bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete a semaphore object and release the memory space.  <br /></td></tr>
<tr class="separator:ga0e45d2b96aab649832b6756d68629bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5de76667b198615400bab78afba6604" id="r_gad5de76667b198615400bab78afba6604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#gad5de76667b198615400bab78afba6604">rt_sem_take</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gad5de76667b198615400bab78afba6604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd87e2484582c79465a6ce9b2f9351fd" id="r_gadd87e2484582c79465a6ce9b2f9351fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#gadd87e2484582c79465a6ce9b2f9351fd">rt_sem_take_interruptible</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gadd87e2484582c79465a6ce9b2f9351fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa393b17a51e88199253e3819175ab5f9" id="r_gaa393b17a51e88199253e3819175ab5f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#gaa393b17a51e88199253e3819175ab5f9">rt_sem_take_killable</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gaa393b17a51e88199253e3819175ab5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf24da991e29df68a49062d89b95c7de5" id="r_gaf24da991e29df68a49062d89b95c7de5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#gaf24da991e29df68a49062d89b95c7de5">rt_sem_trytake</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem)</td></tr>
<tr class="memdesc:gaf24da991e29df68a49062d89b95c7de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to take a semaphore, if the semaphore is unavailable, the thread returns immediately.  <br /></td></tr>
<tr class="separator:gaf24da991e29df68a49062d89b95c7de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a5760bc4c7faeb08a7d9c112506f76" id="r_gad9a5760bc4c7faeb08a7d9c112506f76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#gad9a5760bc4c7faeb08a7d9c112506f76">rt_sem_release</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem)</td></tr>
<tr class="memdesc:gad9a5760bc4c7faeb08a7d9c112506f76"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will release a semaphore. If there is thread suspended on the semaphore, it will get resumed.  <br /></td></tr>
<tr class="separator:gad9a5760bc4c7faeb08a7d9c112506f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569a571566b70682422a8fc5bd53f06f" id="r_ga569a571566b70682422a8fc5bd53f06f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__semaphore.html#ga569a571566b70682422a8fc5bd53f06f">rt_sem_control</a> (<a class="el" href="group__group__semaphore.html#gaae61bc48262a327841eff7616d3af9c0">rt_sem_t</a> sem, int cmd, void *arg)</td></tr>
<tr class="memdesc:ga569a571566b70682422a8fc5bd53f06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set some extra attributions of a semaphore object.  <br /></td></tr>
<tr class="separator:ga569a571566b70682422a8fc5bd53f06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90c29e470fff8981a976ec7f9bb0546e" id="r_ga90c29e470fff8981a976ec7f9bb0546e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga90c29e470fff8981a976ec7f9bb0546e">rt_mutex_init</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex, const char *name, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga90c29e470fff8981a976ec7f9bb0546e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a static mutex object.  <br /></td></tr>
<tr class="separator:ga90c29e470fff8981a976ec7f9bb0546e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a8b48c0e6884e2c22d08e9e7e98a613" id="r_ga7a8b48c0e6884e2c22d08e9e7e98a613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga7a8b48c0e6884e2c22d08e9e7e98a613">rt_mutex_detach</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex)</td></tr>
<tr class="memdesc:ga7a8b48c0e6884e2c22d08e9e7e98a613"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a static mutex object.  <br /></td></tr>
<tr class="separator:ga7a8b48c0e6884e2c22d08e9e7e98a613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce96ed48d83086aab6ecadebac6d0c6" id="r_ga5ce96ed48d83086aab6ecadebac6d0c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga5ce96ed48d83086aab6ecadebac6d0c6">rt_mutex_create</a> (const char *name, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga5ce96ed48d83086aab6ecadebac6d0c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will create a mutex object.  <br /></td></tr>
<tr class="separator:ga5ce96ed48d83086aab6ecadebac6d0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a74f51362fc566500bec135599dd5a9" id="r_ga8a74f51362fc566500bec135599dd5a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga8a74f51362fc566500bec135599dd5a9">rt_mutex_delete</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex)</td></tr>
<tr class="memdesc:ga8a74f51362fc566500bec135599dd5a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete a mutex object and release this memory space.  <br /></td></tr>
<tr class="separator:ga8a74f51362fc566500bec135599dd5a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ca03f1e5607cda3f739aff4048b8372" id="r_ga8ca03f1e5607cda3f739aff4048b8372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga8ca03f1e5607cda3f739aff4048b8372">rt_mutex_drop_thread</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex, <a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:ga8ca03f1e5607cda3f739aff4048b8372"><td class="mdescLeft">&#160;</td><td class="mdescRight">drop a thread from the suspend list of mutex  <br /></td></tr>
<tr class="separator:ga8ca03f1e5607cda3f739aff4048b8372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dbba080eb21d82b3877d6e439bdfd28" id="r_ga7dbba080eb21d82b3877d6e439bdfd28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga7dbba080eb21d82b3877d6e439bdfd28">rt_mutex_setprioceiling</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> priority)</td></tr>
<tr class="memdesc:ga7dbba080eb21d82b3877d6e439bdfd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the prioceiling attribute of the mutex.  <br /></td></tr>
<tr class="separator:ga7dbba080eb21d82b3877d6e439bdfd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef430f1dbc50af1098589232fb54508c" id="r_gaef430f1dbc50af1098589232fb54508c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#gaef430f1dbc50af1098589232fb54508c">rt_mutex_getprioceiling</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex)</td></tr>
<tr class="memdesc:gaef430f1dbc50af1098589232fb54508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the prioceiling attribute of the mutex.  <br /></td></tr>
<tr class="separator:gaef430f1dbc50af1098589232fb54508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3b10695d4c703d2efbe67cce128d7d5" id="r_gaa3b10695d4c703d2efbe67cce128d7d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#gaa3b10695d4c703d2efbe67cce128d7d5">rt_mutex_take</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gaa3b10695d4c703d2efbe67cce128d7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada983d7f4521fdb0f7a5cf6d0a1ac800" id="r_gada983d7f4521fdb0f7a5cf6d0a1ac800"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#gada983d7f4521fdb0f7a5cf6d0a1ac800">rt_mutex_trytake</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex)</td></tr>
<tr class="memdesc:gada983d7f4521fdb0f7a5cf6d0a1ac800"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will try to take a mutex, if the mutex is unavailable, the thread returns immediately.  <br /></td></tr>
<tr class="separator:gada983d7f4521fdb0f7a5cf6d0a1ac800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42dfa4d42739821c4b58d82bb76109b0" id="r_ga42dfa4d42739821c4b58d82bb76109b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga42dfa4d42739821c4b58d82bb76109b0">rt_mutex_take_interruptible</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> time)</td></tr>
<tr class="separator:ga42dfa4d42739821c4b58d82bb76109b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7051d1f083e64af332ca952cccb492fe" id="r_ga7051d1f083e64af332ca952cccb492fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga7051d1f083e64af332ca952cccb492fe">rt_mutex_take_killable</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> time)</td></tr>
<tr class="separator:ga7051d1f083e64af332ca952cccb492fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49c2ee6dc578e6687919f01a4ac5137" id="r_gad49c2ee6dc578e6687919f01a4ac5137"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#gad49c2ee6dc578e6687919f01a4ac5137">rt_mutex_release</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex)</td></tr>
<tr class="memdesc:gad49c2ee6dc578e6687919f01a4ac5137"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will release a mutex. If there is thread suspended on the mutex, the thread will be resumed.  <br /></td></tr>
<tr class="separator:gad49c2ee6dc578e6687919f01a4ac5137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e12cce5d8252dd3cc764ba00d429ae9" id="r_ga1e12cce5d8252dd3cc764ba00d429ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga1e12cce5d8252dd3cc764ba00d429ae9">rt_mutex_control</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex, int cmd, void *arg)</td></tr>
<tr class="memdesc:ga1e12cce5d8252dd3cc764ba00d429ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set some extra attributions of a mutex object.  <br /></td></tr>
<tr class="separator:ga1e12cce5d8252dd3cc764ba00d429ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb7d5bdcf5b62d71a08be688f2c383db" id="r_gacb7d5bdcf5b62d71a08be688f2c383db"><td class="memItemLeft" align="right" valign="top">rt_inline <a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#gacb7d5bdcf5b62d71a08be688f2c383db">rt_mutex_get_owner</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex)</td></tr>
<tr class="separator:gacb7d5bdcf5b62d71a08be688f2c383db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f05dc88a5c4c56c7f03d81536bc0335" id="r_ga6f05dc88a5c4c56c7f03d81536bc0335"><td class="memItemLeft" align="right" valign="top">rt_inline <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mutex.html#ga6f05dc88a5c4c56c7f03d81536bc0335">rt_mutex_get_hold</a> (<a class="el" href="group__group__mutex.html#gad8f835bf8b44455c44e67eb1f3a2383f">rt_mutex_t</a> mutex)</td></tr>
<tr class="separator:ga6f05dc88a5c4c56c7f03d81536bc0335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0fad38227b1ebd616a807a09f2eb772" id="r_gab0fad38227b1ebd616a807a09f2eb772"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#gab0fad38227b1ebd616a807a09f2eb772">rt_event_init</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event, const char *name, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:gab0fad38227b1ebd616a807a09f2eb772"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function will initialize a static event object.  <br /></td></tr>
<tr class="separator:gab0fad38227b1ebd616a807a09f2eb772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43f0b137c7e6d5c2152f6b1d39b57616" id="r_ga43f0b137c7e6d5c2152f6b1d39b57616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#ga43f0b137c7e6d5c2152f6b1d39b57616">rt_event_detach</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event)</td></tr>
<tr class="memdesc:ga43f0b137c7e6d5c2152f6b1d39b57616"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a static event object.  <br /></td></tr>
<tr class="separator:ga43f0b137c7e6d5c2152f6b1d39b57616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d752d98e73c0adcdd2b0df24e67efdb" id="r_ga3d752d98e73c0adcdd2b0df24e67efdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#ga3d752d98e73c0adcdd2b0df24e67efdb">rt_event_create</a> (const char *name, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga3d752d98e73c0adcdd2b0df24e67efdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating an event object.  <br /></td></tr>
<tr class="separator:ga3d752d98e73c0adcdd2b0df24e67efdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga840d6210713f186fe248a032a68d5e6d" id="r_ga840d6210713f186fe248a032a68d5e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#ga840d6210713f186fe248a032a68d5e6d">rt_event_delete</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event)</td></tr>
<tr class="memdesc:ga840d6210713f186fe248a032a68d5e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete an event object and release the memory space.  <br /></td></tr>
<tr class="separator:ga840d6210713f186fe248a032a68d5e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92efdf32aaf073d733f3bafd02d730e5" id="r_ga92efdf32aaf073d733f3bafd02d730e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#ga92efdf32aaf073d733f3bafd02d730e5">rt_event_send</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> set)</td></tr>
<tr class="memdesc:ga92efdf32aaf073d733f3bafd02d730e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will send an event to the event object. If there is a thread suspended on the event, the thread will be resumed.  <br /></td></tr>
<tr class="separator:ga92efdf32aaf073d733f3bafd02d730e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf01ab3359471613143fb0a1bc4317baa" id="r_gaf01ab3359471613143fb0a1bc4317baa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#gaf01ab3359471613143fb0a1bc4317baa">rt_event_recv</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> set, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> opt, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> *recved)</td></tr>
<tr class="separator:gaf01ab3359471613143fb0a1bc4317baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02aef6da1f8a5504424b9302991adc4b" id="r_ga02aef6da1f8a5504424b9302991adc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#ga02aef6da1f8a5504424b9302991adc4b">rt_event_recv_interruptible</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> set, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> opt, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> *recved)</td></tr>
<tr class="separator:ga02aef6da1f8a5504424b9302991adc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6657cd85ef9e25e1f4002aa313865853" id="r_ga6657cd85ef9e25e1f4002aa313865853"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#ga6657cd85ef9e25e1f4002aa313865853">rt_event_recv_killable</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> set, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> opt, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout, <a class="el" href="rttypes_8h.html#aa0f407376acf6e5854ea411316811418">rt_uint32_t</a> *recved)</td></tr>
<tr class="separator:ga6657cd85ef9e25e1f4002aa313865853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3aeb964ccccdde76bb5e247c0a913fea" id="r_ga3aeb964ccccdde76bb5e247c0a913fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__event.html#ga3aeb964ccccdde76bb5e247c0a913fea">rt_event_control</a> (<a class="el" href="group__group__event.html#gad94b8b2a97683ff35478b7a0adef60df">rt_event_t</a> event, int cmd, void *arg)</td></tr>
<tr class="memdesc:ga3aeb964ccccdde76bb5e247c0a913fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set some extra attributions of an event object.  <br /></td></tr>
<tr class="separator:ga3aeb964ccccdde76bb5e247c0a913fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac05bd0c179f754c32f83a7b013e8953b" id="r_gac05bd0c179f754c32f83a7b013e8953b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#gac05bd0c179f754c32f83a7b013e8953b">rt_mb_init</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, const char *name, void *msgpool, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:gac05bd0c179f754c32f83a7b013e8953b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a static mailbox object.  <br /></td></tr>
<tr class="separator:gac05bd0c179f754c32f83a7b013e8953b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3312c6094d9c21af33a74f444a8c5993" id="r_ga3312c6094d9c21af33a74f444a8c5993"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga3312c6094d9c21af33a74f444a8c5993">rt_mb_detach</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb)</td></tr>
<tr class="memdesc:ga3312c6094d9c21af33a74f444a8c5993"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a static mailbox object.  <br /></td></tr>
<tr class="separator:ga3312c6094d9c21af33a74f444a8c5993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7719d644b6f58399894dec1c6353ac37" id="r_ga7719d644b6f58399894dec1c6353ac37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga7719d644b6f58399894dec1c6353ac37">rt_mb_create</a> (const char *name, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga7719d644b6f58399894dec1c6353ac37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a mailbox object.  <br /></td></tr>
<tr class="separator:ga7719d644b6f58399894dec1c6353ac37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e9e49401cbbed83515ace6fa13c27b" id="r_ga71e9e49401cbbed83515ace6fa13c27b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga71e9e49401cbbed83515ace6fa13c27b">rt_mb_delete</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb)</td></tr>
<tr class="memdesc:ga71e9e49401cbbed83515ace6fa13c27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete a mailbox object and release the memory space.  <br /></td></tr>
<tr class="separator:ga71e9e49401cbbed83515ace6fa13c27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2b0d532eab2989b713fdb0b1fac6665" id="r_gac2b0d532eab2989b713fdb0b1fac6665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#gac2b0d532eab2989b713fdb0b1fac6665">rt_mb_send</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> value)</td></tr>
<tr class="memdesc:gac2b0d532eab2989b713fdb0b1fac6665"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will send an mail to the mailbox object. If there is a thread suspended on the mailbox, the thread will be resumed.  <br /></td></tr>
<tr class="separator:gac2b0d532eab2989b713fdb0b1fac6665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9900f76119a771e2a07c6eaf7ae95294" id="r_ga9900f76119a771e2a07c6eaf7ae95294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga9900f76119a771e2a07c6eaf7ae95294">rt_mb_send_interruptible</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> value)</td></tr>
<tr class="separator:ga9900f76119a771e2a07c6eaf7ae95294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c963f86bc506afa91a97b08fb63d2c8" id="r_ga3c963f86bc506afa91a97b08fb63d2c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga3c963f86bc506afa91a97b08fb63d2c8">rt_mb_send_killable</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> value)</td></tr>
<tr class="separator:ga3c963f86bc506afa91a97b08fb63d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad39b8b365c2168d697c89de80f0498d0" id="r_gad39b8b365c2168d697c89de80f0498d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#gad39b8b365c2168d697c89de80f0498d0">rt_mb_send_wait</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> value, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gad39b8b365c2168d697c89de80f0498d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad97bb963f28af671bd3adc9a9b8ad2f7" id="r_gad97bb963f28af671bd3adc9a9b8ad2f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#gad97bb963f28af671bd3adc9a9b8ad2f7">rt_mb_send_wait_interruptible</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> value, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gad97bb963f28af671bd3adc9a9b8ad2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329a6f3cdd8a74024a80ebe4b7fa5abd" id="r_ga329a6f3cdd8a74024a80ebe4b7fa5abd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga329a6f3cdd8a74024a80ebe4b7fa5abd">rt_mb_send_wait_killable</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> value, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga329a6f3cdd8a74024a80ebe4b7fa5abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc9da3320cdbeee5aa86e65cdf48f928" id="r_gabc9da3320cdbeee5aa86e65cdf48f928"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#gabc9da3320cdbeee5aa86e65cdf48f928">rt_mb_urgent</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> value)</td></tr>
<tr class="memdesc:gabc9da3320cdbeee5aa86e65cdf48f928"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will send an urgent mail to the mailbox object.  <br /></td></tr>
<tr class="separator:gabc9da3320cdbeee5aa86e65cdf48f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fe9492b9f797650c8a1ced2e9d8c9ae" id="r_ga4fe9492b9f797650c8a1ced2e9d8c9ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga4fe9492b9f797650c8a1ced2e9d8c9ae">rt_mb_recv</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> *value, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga4fe9492b9f797650c8a1ced2e9d8c9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9304fcbb50b32abf913673b0b6be32e7" id="r_ga9304fcbb50b32abf913673b0b6be32e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga9304fcbb50b32abf913673b0b6be32e7">rt_mb_recv_interruptible</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> *value, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga9304fcbb50b32abf913673b0b6be32e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga007f010abaed3f902dff9e214e256294" id="r_ga007f010abaed3f902dff9e214e256294"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga007f010abaed3f902dff9e214e256294">rt_mb_recv_killable</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> *value, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga007f010abaed3f902dff9e214e256294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18c381ffe3aab6dea429c98ecfcea44c" id="r_ga18c381ffe3aab6dea429c98ecfcea44c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__mailbox.html#ga18c381ffe3aab6dea429c98ecfcea44c">rt_mb_control</a> (<a class="el" href="group__group__mailbox.html#ga96b4618b92ab16611956ffd77c330d5e">rt_mailbox_t</a> mb, int cmd, void *arg)</td></tr>
<tr class="memdesc:ga18c381ffe3aab6dea429c98ecfcea44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set some extra attributions of a mailbox object.  <br /></td></tr>
<tr class="separator:ga18c381ffe3aab6dea429c98ecfcea44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac5b76df894964c908271ab0951f7e86" id="r_gaac5b76df894964c908271ab0951f7e86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#gaac5b76df894964c908271ab0951f7e86">rt_mq_init</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const char *name, void *msgpool, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> msg_size, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> pool_size, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:gaac5b76df894964c908271ab0951f7e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a static messagequeue object.  <br /></td></tr>
<tr class="separator:gaac5b76df894964c908271ab0951f7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ed6238494fac3ab081a90d9c563a8f3" id="r_ga1ed6238494fac3ab081a90d9c563a8f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga1ed6238494fac3ab081a90d9c563a8f3">rt_mq_detach</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq)</td></tr>
<tr class="memdesc:ga1ed6238494fac3ab081a90d9c563a8f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will detach a static messagequeue object.  <br /></td></tr>
<tr class="separator:ga1ed6238494fac3ab081a90d9c563a8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35acff654ecee2a76d5555e9683d8470" id="r_ga35acff654ecee2a76d5555e9683d8470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga35acff654ecee2a76d5555e9683d8470">rt_mq_create</a> (const char *name, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> msg_size, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> max_msgs, <a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a> flag)</td></tr>
<tr class="memdesc:ga35acff654ecee2a76d5555e9683d8470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating a messagequeue object.  <br /></td></tr>
<tr class="separator:ga35acff654ecee2a76d5555e9683d8470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf0bfedc6677ca8357d8b345c9026c9" id="r_gacbf0bfedc6677ca8357d8b345c9026c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#gacbf0bfedc6677ca8357d8b345c9026c9">rt_mq_delete</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq)</td></tr>
<tr class="memdesc:gacbf0bfedc6677ca8357d8b345c9026c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will delete a messagequeue object and release the memory.  <br /></td></tr>
<tr class="separator:gacbf0bfedc6677ca8357d8b345c9026c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3d128f328e2e979f0ee86d633937e4e" id="r_gab3d128f328e2e979f0ee86d633937e4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#gab3d128f328e2e979f0ee86d633937e4e">rt_mq_send</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="memdesc:gab3d128f328e2e979f0ee86d633937e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will send a message to the messagequeue object. If there is a thread suspended on the messagequeue, the thread will be resumed.  <br /></td></tr>
<tr class="separator:gab3d128f328e2e979f0ee86d633937e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b426601c886c46dcc7546e135d1b971" id="r_ga7b426601c886c46dcc7546e135d1b971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga7b426601c886c46dcc7546e135d1b971">rt_mq_send_interruptible</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="separator:ga7b426601c886c46dcc7546e135d1b971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d62ff6c3c18cc822e8ad6f71a7b691" id="r_ga77d62ff6c3c18cc822e8ad6f71a7b691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga77d62ff6c3c18cc822e8ad6f71a7b691">rt_mq_send_killable</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="separator:ga77d62ff6c3c18cc822e8ad6f71a7b691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a041666764bd3a737e6451e6e40887a" id="r_ga0a041666764bd3a737e6451e6e40887a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga0a041666764bd3a737e6451e6e40887a">rt_mq_send_wait</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga0a041666764bd3a737e6451e6e40887a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac888fea9179aa21a44fccb70771fac69" id="r_gac888fea9179aa21a44fccb70771fac69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#gac888fea9179aa21a44fccb70771fac69">rt_mq_send_wait_interruptible</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gac888fea9179aa21a44fccb70771fac69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ebc10b837cd2245a9be2b26a4ecfb4" id="r_ga52ebc10b837cd2245a9be2b26a4ecfb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga52ebc10b837cd2245a9be2b26a4ecfb4">rt_mq_send_wait_killable</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga52ebc10b837cd2245a9be2b26a4ecfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb1abee716f2f5c24a36aff2ffd32c75" id="r_gafb1abee716f2f5c24a36aff2ffd32c75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#gafb1abee716f2f5c24a36aff2ffd32c75">rt_mq_urgent</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="memdesc:gafb1abee716f2f5c24a36aff2ffd32c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will send an urgent message to the messagequeue object.  <br /></td></tr>
<tr class="separator:gafb1abee716f2f5c24a36aff2ffd32c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6a078a9a93a84f5561753f0af6ee93a" id="r_gad6a078a9a93a84f5561753f0af6ee93a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a0838be0f1d323925555279fa1016892e">rt_ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#gad6a078a9a93a84f5561753f0af6ee93a">rt_mq_recv</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:gad6a078a9a93a84f5561753f0af6ee93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db56a8a65402262485037ccb66ed265" id="r_ga9db56a8a65402262485037ccb66ed265"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a0838be0f1d323925555279fa1016892e">rt_ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga9db56a8a65402262485037ccb66ed265">rt_mq_recv_interruptible</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga9db56a8a65402262485037ccb66ed265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6938b9e0b2d88d6f28ee6b97cbffed54" id="r_ga6938b9e0b2d88d6f28ee6b97cbffed54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a0838be0f1d323925555279fa1016892e">rt_ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga6938b9e0b2d88d6f28ee6b97cbffed54">rt_mq_recv_killable</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size, <a class="el" href="rttypes_8h.html#afab3dddb302fee91b8d8cff1c6fae9bd">rt_int32_t</a> timeout)</td></tr>
<tr class="separator:ga6938b9e0b2d88d6f28ee6b97cbffed54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b1ec7b2bfbc8029b0200755505d7c55" id="r_ga3b1ec7b2bfbc8029b0200755505d7c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__messagequeue.html#ga3b1ec7b2bfbc8029b0200755505d7c55">rt_mq_control</a> (<a class="el" href="group__group__messagequeue.html#ga5b956264720da4e2dfbbd54e94e54f96">rt_mq_t</a> mq, int cmd, void *arg)</td></tr>
<tr class="memdesc:ga3b1ec7b2bfbc8029b0200755505d7c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set some extra attributions of a messagequeue object.  <br /></td></tr>
<tr class="separator:ga3b1ec7b2bfbc8029b0200755505d7c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f3409da6056a0ab7abfc179e32c6f3a" id="r_ga3f3409da6056a0ab7abfc179e32c6f3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga3f3409da6056a0ab7abfc179e32c6f3a">rt_thread_defunct_init</a> (void)</td></tr>
<tr class="separator:ga3f3409da6056a0ab7abfc179e32c6f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e32f5a4ae6b0da7771e08b061eba1ee" id="r_ga0e32f5a4ae6b0da7771e08b061eba1ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga0e32f5a4ae6b0da7771e08b061eba1ee">rt_thread_defunct_enqueue</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:ga0e32f5a4ae6b0da7771e08b061eba1ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue a thread to defunct queue.  <br /></td></tr>
<tr class="separator:ga0e32f5a4ae6b0da7771e08b061eba1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f8bcf6aa8d872a07261a8faaa026ba" id="r_ga35f8bcf6aa8d872a07261a8faaa026ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga35f8bcf6aa8d872a07261a8faaa026ba">rt_thread_defunct_dequeue</a> (void)</td></tr>
<tr class="memdesc:ga35f8bcf6aa8d872a07261a8faaa026ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeue a thread from defunct queue.  <br /></td></tr>
<tr class="separator:ga35f8bcf6aa8d872a07261a8faaa026ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1de245140734ab9388eb11300e923f79" id="r_ga1de245140734ab9388eb11300e923f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga1de245140734ab9388eb11300e923f79">rt_defunct_execute</a> (void)</td></tr>
<tr class="memdesc:ga1de245140734ab9388eb11300e923f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will perform system background job when system idle.  <br /></td></tr>
<tr class="separator:ga1de245140734ab9388eb11300e923f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda9721c7e7e2d27e53f0b4604dd65dd" id="r_gabda9721c7e7e2d27e53f0b4604dd65dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#gabda9721c7e7e2d27e53f0b4604dd65dd">rt_spin_lock_init</a> (struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *lock)</td></tr>
<tr class="memdesc:gabda9721c7e7e2d27e53f0b4604dd65dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a static spinlock object.  <br /></td></tr>
<tr class="separator:gabda9721c7e7e2d27e53f0b4604dd65dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e3b84e1f0acebdd5ae36b0626b24240" id="r_ga9e3b84e1f0acebdd5ae36b0626b24240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga9e3b84e1f0acebdd5ae36b0626b24240">rt_spin_lock</a> (struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *lock)</td></tr>
<tr class="memdesc:ga9e3b84e1f0acebdd5ae36b0626b24240"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will lock the spinlock, will lock the thread scheduler.  <br /></td></tr>
<tr class="separator:ga9e3b84e1f0acebdd5ae36b0626b24240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2f7760a8299108cd4ba8a9135ef4f93" id="r_gac2f7760a8299108cd4ba8a9135ef4f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#gac2f7760a8299108cd4ba8a9135ef4f93">rt_spin_unlock</a> (struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *lock)</td></tr>
<tr class="memdesc:gac2f7760a8299108cd4ba8a9135ef4f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will unlock the spinlock, will unlock the thread scheduler.  <br /></td></tr>
<tr class="separator:gac2f7760a8299108cd4ba8a9135ef4f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga349989d50ad6f1b3bbe508b0cd7051f1" id="r_ga349989d50ad6f1b3bbe508b0cd7051f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a0903689e9212375ba7d0de65c3adfece">rt_base_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#ga349989d50ad6f1b3bbe508b0cd7051f1">rt_spin_lock_irqsave</a> (struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *lock)</td></tr>
<tr class="memdesc:ga349989d50ad6f1b3bbe508b0cd7051f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will disable the local interrupt and then lock the spinlock, will lock the thread scheduler.  <br /></td></tr>
<tr class="separator:ga349989d50ad6f1b3bbe508b0cd7051f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed628fa8199becf4d3c6ea12cf8d6991" id="r_gaed628fa8199becf4d3c6ea12cf8d6991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___i_p_c.html#gaed628fa8199becf4d3c6ea12cf8d6991">rt_spin_unlock_irqrestore</a> (struct <a class="el" href="structrt__spinlock.html">rt_spinlock</a> *lock, <a class="el" href="rttypes_8h.html#a0903689e9212375ba7d0de65c3adfece">rt_base_t</a> level)</td></tr>
<tr class="memdesc:gaed628fa8199becf4d3c6ea12cf8d6991"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will unlock the spinlock and then restore current cpu interrupt status, will unlock the thread scheduler.  <br /></td></tr>
<tr class="separator:gaed628fa8199becf4d3c6ea12cf8d6991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fb604dd486fbf5e48004b4d94d8eb3e" id="r_ga7fb604dd486fbf5e48004b4d94d8eb3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga7fb604dd486fbf5e48004b4d94d8eb3e">rt_device_find</a> (const char *name)</td></tr>
<tr class="separator:ga7fb604dd486fbf5e48004b4d94d8eb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa44b227c43321faffb198ef9c0bb17e" id="r_gaaa44b227c43321faffb198ef9c0bb17e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#gaaa44b227c43321faffb198ef9c0bb17e">rt_device_register</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, const char *name, <a class="el" href="rttypes_8h.html#a5acba55f46553417996ac70828b874da">rt_uint16_t</a> flags)</td></tr>
<tr class="separator:gaaa44b227c43321faffb198ef9c0bb17e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76cf284581e36b7e2244398efbf850b5" id="r_ga76cf284581e36b7e2244398efbf850b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga76cf284581e36b7e2244398efbf850b5">rt_device_unregister</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev)</td></tr>
<tr class="separator:ga76cf284581e36b7e2244398efbf850b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61ad2adb3c48709087465f61c244733b" id="r_ga61ad2adb3c48709087465f61c244733b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga61ad2adb3c48709087465f61c244733b">rt_device_create</a> (int type, int attach_size)</td></tr>
<tr class="separator:ga61ad2adb3c48709087465f61c244733b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74b22c6a450071b23774fe24bf6fc78c" id="r_ga74b22c6a450071b23774fe24bf6fc78c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga74b22c6a450071b23774fe24bf6fc78c">rt_device_destroy</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> device)</td></tr>
<tr class="separator:ga74b22c6a450071b23774fe24bf6fc78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07dfc7fd340b9449d2bd732159ed237f" id="r_ga07dfc7fd340b9449d2bd732159ed237f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga07dfc7fd340b9449d2bd732159ed237f">rt_device_set_rx_indicate</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, <a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>(*rx_ind)(<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size))</td></tr>
<tr class="separator:ga07dfc7fd340b9449d2bd732159ed237f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6340392a3848e3f5e324aa984375b07" id="r_gae6340392a3848e3f5e324aa984375b07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#gae6340392a3848e3f5e324aa984375b07">rt_device_set_tx_complete</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, <a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>(*tx_done)(<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, void *buffer))</td></tr>
<tr class="separator:gae6340392a3848e3f5e324aa984375b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04892007706fe586a1db33284571be7e" id="r_ga04892007706fe586a1db33284571be7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga04892007706fe586a1db33284571be7e">rt_device_init</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev)</td></tr>
<tr class="separator:ga04892007706fe586a1db33284571be7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0cd9f7a81722d69e8720ea4750c17a2" id="r_gac0cd9f7a81722d69e8720ea4750c17a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#gac0cd9f7a81722d69e8720ea4750c17a2">rt_device_open</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, <a class="el" href="rttypes_8h.html#a5acba55f46553417996ac70828b874da">rt_uint16_t</a> oflag)</td></tr>
<tr class="separator:gac0cd9f7a81722d69e8720ea4750c17a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914535247ea0e5477002553ad38b1482" id="r_ga914535247ea0e5477002553ad38b1482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga914535247ea0e5477002553ad38b1482">rt_device_close</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev)</td></tr>
<tr class="separator:ga914535247ea0e5477002553ad38b1482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51642e30d61927aece593ee23d090b17" id="r_ga51642e30d61927aece593ee23d090b17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a0838be0f1d323925555279fa1016892e">rt_ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga51642e30d61927aece593ee23d090b17">rt_device_read</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, <a class="el" href="rttypes_8h.html#a0fd4981851ce935649b6723a81f2f1bf">rt_off_t</a> pos, void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="separator:ga51642e30d61927aece593ee23d090b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f1525de3aec696b4781b790df9759df" id="r_ga4f1525de3aec696b4781b790df9759df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a0838be0f1d323925555279fa1016892e">rt_ssize_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga4f1525de3aec696b4781b790df9759df">rt_device_write</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, <a class="el" href="rttypes_8h.html#a0fd4981851ce935649b6723a81f2f1bf">rt_off_t</a> pos, const void *buffer, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size)</td></tr>
<tr class="separator:ga4f1525de3aec696b4781b790df9759df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ed6da2d5ea7b1e28de21ff439db963" id="r_ga40ed6da2d5ea7b1e28de21ff439db963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__device__driver.html#ga40ed6da2d5ea7b1e28de21ff439db963">rt_device_control</a> (<a class="el" href="group__group__device__driver.html#ga896a5cd63480a02303252f41782379b1">rt_device_t</a> dev, int cmd, void *arg)</td></tr>
<tr class="separator:ga40ed6da2d5ea7b1e28de21ff439db963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga020fb2151c8cbf1c1c0c59e615dc8d9e" id="r_ga020fb2151c8cbf1c1c0c59e615dc8d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__kernel__core.html#ga020fb2151c8cbf1c1c0c59e615dc8d9e">rt_interrupt_enter</a> (void)</td></tr>
<tr class="memdesc:ga020fb2151c8cbf1c1c0c59e615dc8d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be invoked by BSP, when enter interrupt service routine.  <br /></td></tr>
<tr class="separator:ga020fb2151c8cbf1c1c0c59e615dc8d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafcbcfbf20707e21e8922a837bba4908d" id="r_gafcbcfbf20707e21e8922a837bba4908d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__kernel__core.html#gafcbcfbf20707e21e8922a837bba4908d">rt_interrupt_leave</a> (void)</td></tr>
<tr class="memdesc:gafcbcfbf20707e21e8922a837bba4908d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will be invoked by BSP, when leave interrupt service routine.  <br /></td></tr>
<tr class="separator:gafcbcfbf20707e21e8922a837bba4908d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1678b19a131d1229ffa93e44835432f0" id="r_a1678b19a131d1229ffa93e44835432f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#a1678b19a131d1229ffa93e44835432f0">rt_interrupt_context_push</a> (<a class="el" href="group__group___thread.html#gae496369bc5dcfd1c6de1425d7f45f79d">rt_interrupt_context_t</a> this_ctx)</td></tr>
<tr class="separator:a1678b19a131d1229ffa93e44835432f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8196ed3ee7f00b8f06647cebca880e0" id="r_aa8196ed3ee7f00b8f06647cebca880e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#aa8196ed3ee7f00b8f06647cebca880e0">rt_interrupt_context_pop</a> (void)</td></tr>
<tr class="separator:aa8196ed3ee7f00b8f06647cebca880e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9863ab218fda2afe8b58bed33757ae" id="r_add9863ab218fda2afe8b58bed33757ae"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#add9863ab218fda2afe8b58bed33757ae">rt_interrupt_context_get</a> (void)</td></tr>
<tr class="separator:add9863ab218fda2afe8b58bed33757ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa122deb2a95014cb2e5fb00d02af8f42" id="r_aa122deb2a95014cb2e5fb00d02af8f42"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrt__cpu.html">rt_cpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#aa122deb2a95014cb2e5fb00d02af8f42">rt_cpu_self</a> (void)</td></tr>
<tr class="memdesc:aa122deb2a95014cb2e5fb00d02af8f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion will return current cpu object.  <br /></td></tr>
<tr class="separator:aa122deb2a95014cb2e5fb00d02af8f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997715e5ce33f228bde848fb1bb9b118" id="r_a997715e5ce33f228bde848fb1bb9b118"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structrt__cpu.html">rt_cpu</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#a997715e5ce33f228bde848fb1bb9b118">rt_cpu_index</a> (int index)</td></tr>
<tr class="memdesc:a997715e5ce33f228bde848fb1bb9b118"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion will return the cpu object corresponding to index.  <br /></td></tr>
<tr class="separator:a997715e5ce33f228bde848fb1bb9b118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6725f61bed47e0d5ac383eccf14d3f1" id="r_gaa6725f61bed47e0d5ac383eccf14d3f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a585e2ad0fbab0f83817cb61373465df6">rt_uint8_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__kernel__core.html#gaa6725f61bed47e0d5ac383eccf14d3f1">rt_interrupt_get_nest</a> (void)</td></tr>
<tr class="memdesc:gaa6725f61bed47e0d5ac383eccf14d3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will return the nest of interrupt.  <br /></td></tr>
<tr class="separator:gaa6725f61bed47e0d5ac383eccf14d3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe1feee9c0028f9bb573f599394d765" id="r_a7fe1feee9c0028f9bb573f599394d765"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#a7fe1feee9c0028f9bb573f599394d765">rt_interrupt_enter_sethook</a> (void(*hook)(void))</td></tr>
<tr class="separator:a7fe1feee9c0028f9bb573f599394d765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958860e3d739bbf4f7390a2591a9cfc4" id="r_a958860e3d739bbf4f7390a2591a9cfc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtthread_8h.html#a958860e3d739bbf4f7390a2591a9cfc4">rt_interrupt_leave_sethook</a> (void(*hook)(void))</td></tr>
<tr class="separator:a958860e3d739bbf4f7390a2591a9cfc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85be8bb029adb3d02ec13f1783c84e50" id="r_ga85be8bb029adb3d02ec13f1783c84e50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga85be8bb029adb3d02ec13f1783c84e50">rt_backtrace</a> (void)</td></tr>
<tr class="memdesc:ga85be8bb029adb3d02ec13f1783c84e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print backtrace of current thread to system console device.  <br /></td></tr>
<tr class="separator:ga85be8bb029adb3d02ec13f1783c84e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8fdd74e45a7037133c40b6f259f003e" id="r_gaf8fdd74e45a7037133c40b6f259f003e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#gaf8fdd74e45a7037133c40b6f259f003e">rt_backtrace_thread</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread)</td></tr>
<tr class="memdesc:gaf8fdd74e45a7037133c40b6f259f003e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print backtrace of a thread to system console device.  <br /></td></tr>
<tr class="separator:gaf8fdd74e45a7037133c40b6f259f003e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga392ed513713b39274f519f1465df2d21" id="r_ga392ed513713b39274f519f1465df2d21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga392ed513713b39274f519f1465df2d21">rt_backtrace_frame</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread, struct <a class="el" href="structrt__hw__backtrace__frame.html">rt_hw_backtrace_frame</a> *frame)</td></tr>
<tr class="memdesc:ga392ed513713b39274f519f1465df2d21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print backtrace from frame to system console device.  <br /></td></tr>
<tr class="separator:ga392ed513713b39274f519f1465df2d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d83c6b256f9de644586f4e438055d17" id="r_ga9d83c6b256f9de644586f4e438055d17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga9d83c6b256f9de644586f4e438055d17">rt_backtrace_formatted_print</a> (<a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> *buffer, long buflen)</td></tr>
<tr class="memdesc:ga9d83c6b256f9de644586f4e438055d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print backtrace from buffer to system console.  <br /></td></tr>
<tr class="separator:ga9d83c6b256f9de644586f4e438055d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8dd0b1b14bbf165eaba7d62b253ac4a3" id="r_ga8dd0b1b14bbf165eaba7d62b253ac4a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rttypes_8h.html#a42df42aabf676f2a89f5af2208b79950">rt_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga8dd0b1b14bbf165eaba7d62b253ac4a3">rt_backtrace_to_buffer</a> (<a class="el" href="group__group___thread.html#gad617ac6bd69bf546743549542a86fbf9">rt_thread_t</a> thread, struct <a class="el" href="structrt__hw__backtrace__frame.html">rt_hw_backtrace_frame</a> *frame, long skip, <a class="el" href="rttypes_8h.html#ab1fea6250be26e7de7cc2d949f755487">rt_ubase_t</a> *buffer, long buflen)</td></tr>
<tr class="memdesc:ga8dd0b1b14bbf165eaba7d62b253ac4a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print backtrace from frame to the given buffer.  <br /></td></tr>
<tr class="separator:ga8dd0b1b14bbf165eaba7d62b253ac4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf225812decad1a6d9036626273ba9e65" id="r_gaf225812decad1a6d9036626273ba9e65"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#gaf225812decad1a6d9036626273ba9e65">__rt_ffs</a> (int value)</td></tr>
<tr class="memdesc:gaf225812decad1a6d9036626273ba9e65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the first bit set (beginning with the least significant bit) in value and return the index of that bit.  <br /></td></tr>
<tr class="separator:gaf225812decad1a6d9036626273ba9e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga887607f16e38b1931d615e507b8bba26" id="r_ga887607f16e38b1931d615e507b8bba26"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga887607f16e38b1931d615e507b8bba26">__rt_ffsl</a> (unsigned long value)</td></tr>
<tr class="separator:ga887607f16e38b1931d615e507b8bba26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92817cb93f23a2539f7d4099812755d9" id="r_ga92817cb93f23a2539f7d4099812755d9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga92817cb93f23a2539f7d4099812755d9">__rt_clz</a> (unsigned long value)</td></tr>
<tr class="separator:ga92817cb93f23a2539f7d4099812755d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga11ecdcdb5b09e6e18b52625c1e904dca" id="r_ga11ecdcdb5b09e6e18b52625c1e904dca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga11ecdcdb5b09e6e18b52625c1e904dca">rt_show_version</a> (void)</td></tr>
<tr class="memdesc:ga11ecdcdb5b09e6e18b52625c1e904dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will show the version of rt-thread rtos.  <br /></td></tr>
<tr class="separator:ga11ecdcdb5b09e6e18b52625c1e904dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga218a15d1a1c2183f9ff42bb3c6cc100a" id="r_ga218a15d1a1c2183f9ff42bb3c6cc100a"><td class="memItemLeft" align="right" valign="top">rt_inline <a class="el" href="rttypes_8h.html#a3e03a3519ef7e33d13ebd34c482db49c">rt_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga218a15d1a1c2183f9ff42bb3c6cc100a">rt_in_thread_context</a> (void)</td></tr>
<tr class="separator:ga218a15d1a1c2183f9ff42bb3c6cc100a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20544e08fe5977d4c5b2b9a8d2e5adb8" id="r_ga20544e08fe5977d4c5b2b9a8d2e5adb8"><td class="memItemLeft" align="right" valign="top">rt_inline <a class="el" href="rttypes_8h.html#a3e03a3519ef7e33d13ebd34c482db49c">rt_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___kernel_service.html#ga20544e08fe5977d4c5b2b9a8d2e5adb8">rt_scheduler_is_available</a> (void)</td></tr>
<tr class="separator:ga20544e08fe5977d4c5b2b9a8d2e5adb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ga72505214bf21fc23dc1595b0442a90af" id="r_ga72505214bf21fc23dc1595b0442a90af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga72505214bf21fc23dc1595b0442a90af">rt_malloc_sethook</a> (void(*hook)(void **ptr, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size))</td></tr>
<tr class="memdesc:ga72505214bf21fc23dc1595b0442a90af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set a hook function, which will be invoked when a memory block is allocated from heap memory.  <br /></td></tr>
<tr class="separator:ga72505214bf21fc23dc1595b0442a90af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec40fa39f9939814ccec29d2f975a3b" id="r_ga3ec40fa39f9939814ccec29d2f975a3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga3ec40fa39f9939814ccec29d2f975a3b">rt_realloc_set_entry_hook</a> (void(*hook)(void **ptr, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size))</td></tr>
<tr class="memdesc:ga3ec40fa39f9939814ccec29d2f975a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set a hook function, which will be invoked when a memory block is allocated from heap memory.  <br /></td></tr>
<tr class="separator:ga3ec40fa39f9939814ccec29d2f975a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032f9f93a115d5549fb24d79df801cac" id="r_ga032f9f93a115d5549fb24d79df801cac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga032f9f93a115d5549fb24d79df801cac">rt_realloc_set_exit_hook</a> (void(*hook)(void **ptr, <a class="el" href="rttypes_8h.html#a8011d259fdfc54b8a9aa006b4d49ac14">rt_size_t</a> size))</td></tr>
<tr class="memdesc:ga032f9f93a115d5549fb24d79df801cac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set a hook function, which will be invoked when a memory block is allocated from heap memory.  <br /></td></tr>
<tr class="separator:ga032f9f93a115d5549fb24d79df801cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bb7426719e954462af2dbe10fc033f2" id="r_ga3bb7426719e954462af2dbe10fc033f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group___m_m.html#ga3bb7426719e954462af2dbe10fc033f2">rt_free_sethook</a> (void(*hook)(void **ptr))</td></tr>
<tr class="memdesc:ga3bb7426719e954462af2dbe10fc033f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will set a hook function, which will be invoked when a memory block is released to heap memory.  <br /></td></tr>
<tr class="separator:ga3bb7426719e954462af2dbe10fc033f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac5294e0b27a4f200d2dbeb7334fdec8b" name="ac5294e0b27a4f200d2dbeb7334fdec8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5294e0b27a4f200d2dbeb7334fdec8b">&#9670;&#160;</a></span>rt_cpu_get_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define rt_cpu_get_id</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">void</td><td>)</td>
          <td>&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a997715e5ce33f228bde848fb1bb9b118" name="a997715e5ce33f228bde848fb1bb9b118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997715e5ce33f228bde848fb1bb9b118">&#9670;&#160;</a></span>rt_cpu_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrt__cpu.html">rt_cpu</a> * rt_cpu_index </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fucntion will return the cpu object corresponding to index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>is the index of target cpu object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the cpu object corresponding to index. </dd></dl>

</div>
</div>
<a id="aa122deb2a95014cb2e5fb00d02af8f42" name="aa122deb2a95014cb2e5fb00d02af8f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa122deb2a95014cb2e5fb00d02af8f42">&#9670;&#160;</a></span>rt_cpu_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structrt__cpu.html">rt_cpu</a> * rt_cpu_self </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fucntion will return current cpu object. </p>
<p>CPU object</p>
<dl class="section return"><dt>Returns</dt><dd>Return a pointer to the current cpu object. </dd></dl>

</div>
</div>
<a id="add9863ab218fda2afe8b58bed33757ae" name="add9863ab218fda2afe8b58bed33757ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9863ab218fda2afe8b58bed33757ae">&#9670;&#160;</a></span>rt_interrupt_context_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * rt_interrupt_context_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8196ed3ee7f00b8f06647cebca880e0" name="aa8196ed3ee7f00b8f06647cebca880e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8196ed3ee7f00b8f06647cebca880e0">&#9670;&#160;</a></span>rt_interrupt_context_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_interrupt_context_pop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1678b19a131d1229ffa93e44835432f0" name="a1678b19a131d1229ffa93e44835432f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1678b19a131d1229ffa93e44835432f0">&#9670;&#160;</a></span>rt_interrupt_context_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_interrupt_context_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group___thread.html#gae496369bc5dcfd1c6de1425d7f45f79d">rt_interrupt_context_t</a>&#160;</td>
          <td class="paramname"><em>this_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fe1feee9c0028f9bb573f599394d765" name="a7fe1feee9c0028f9bb573f599394d765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe1feee9c0028f9bb573f599394d765">&#9670;&#160;</a></span>rt_interrupt_enter_sethook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_interrupt_enter_sethook </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a958860e3d739bbf4f7390a2591a9cfc4" name="a958860e3d739bbf4f7390a2591a9cfc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958860e3d739bbf4f7390a2591a9cfc4">&#9670;&#160;</a></span>rt_interrupt_leave_sethook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rt_interrupt_leave_sethook </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="rtthread_8h.html">rtthread.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
